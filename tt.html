
<html><head>
<style>
#info {
  position: absolute;
  top: 2%;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}

.pass {
  position: absolute;
  border-radius: 50px;
  left : 6%;
  top: 77%;
  width: 80px;
  height: 80px;
  background-image: url(https://i.imgur.com/uewilpE.png);
  background-size: cover;
  transition: all 0.5s;
}

.pass.btn-active {
  background-image: url(https://i.imgur.com/OVO20Sn.png);
}

.spike {
  position: absolute;
  border-radius: 50px;
  left : 13%;
  top: 77%;
  width: 80px;
  height: 80px;
  background-image: url(https://i.imgur.com/fDoF6E1.png);
  background-size: cover;
  transition: all 0.5s;
}

.spike.btn-active {
  background-image: url(https://i.imgur.com/ehUlaMl.png);
}

.start {
  position: absolute;
  border-radius: 50px;
  left : 20%;
  top: 77%;
  width: 80px;
  height: 80px;
  background-image: url(https://i.imgur.com/4jtk3xp.png);
  background-size: cover;
  transition: all 0.5s;
}

.start.btn-active {
  background-color:#ffff00;
}
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://rawgit.com/jyunming-chen/tutsplus/master/js/text2D.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://youtingkuo.github.io/volleyball/basicScene.js"></script>
<script src="https://youtingkuo.github.io/volleyball/ball.js"></script>
<script src="https://youtingkuo.github.io/volleyball/player.js"></script>
<script src="https://youtingkuo.github.io/volleyball/referee.js"></script>
<script src="https://youtingkuo.github.io/volleyball/linesPerson.js"></script>
<script src="https://youtingkuo.github.io/volleyball/coach.js"></script>
<script src="https://youtingkuo.github.io/volleyball/agent.js"></script>
<script src="https://youtingkuo.github.io/volleyball/robot.js"></script>
<audio id="soundtrack" autoplay loop style="display:none"></audio>
<audio id="slapSound" style="display:none">
<source src="https://youtingkuo.github.io/sound/slap.mp3" type='audio/mp3'>
</audio>
<audio id="spikeSound" style="display:none">
<source src="https://youtingkuo.github.io/sound/spike.mp3" type='audio/mp3'>
</audio>
</head>

<body> 
<div id="info"></div>
<button id='pass' class='pass'></button>
<button id='spike' class='spike' ></button>
<button id='start' class='start'></button>

<script>

var BUMP = Math.PI/3.49;
var player = function(npc, num) {
		
    this.state = 0; //0:待機  1:發球 2:standBy 3:做球 4:normal攻擊 5:殺球攻擊 //6:移動到殺球地點
    this.npc = npc; //1：電腦, 2：玩家
    this.num = num; //背號
    this.standByPosition = new THREE.Vector3(0, 0, 0);
    this.chaseTarget = new THREE.Vector3(0, 0 ,0);
    this.hitMode = 0;
    //發球用
		this.serveAngleLeft = 0;
		this.serveAngleRight = 0;
		this.startTime = 0;
		this.serveIsOn = false;
		this.serveState = 0;//0,左右手往後 1,右手往前 2,打到球後兩手收回
    this.serveTarget;
    this.isLeft = false;
    //update用
    this.updateAngleLeft = BUMP;
    this.updateAngleRight = BUMP;
    //跳越用
    this.jumpIsOn = false;
	this.jumpServeIsOn = false;
    this.jumpStartTime = 0;
	this.jumpServeState = 0//0:拋球動作，1:拋完球standBy不動，2跳起來，3手準備揮,4手揮出，球射出去了,手正在歸位,5手歸完位，身體正在歸位(著地)
  	this.jumpV = new THREE.Vector3(0, 0, 0);
    this.jumpWaitTime = 0;//等待時間，發球跟殺球共用
    this.jumpState = 0;
    
    //玩家操控的攻擊點
    this.attackTarget = new THREE.Vector3(-4, 0, 0);
    //
    this.preTarget = new THREE.Vector3(0, 0, 0);
    
    this.board = new Agent (new THREE.Vector3 (0, 0, 0), new THREE.Vector3(0,0,0));
    this.robot = new robot (scene, npc, this.num);
    scene.add(this.board.mesh);
    
    this.bump();
 	
  	
 		this.sprite = new SpriteText2D('seek', {
    	align: textAlign.center,
    	font: '20px Courier',
    	fillStyle: '#000000',
    	antialias: true
 	 	});
    this.sprite.scale.set(.02, .02, .02);
  	scene.add(this.sprite);
}

player.prototype.bump = function(){
    if(this.npc) {
    	this.robot.body.rotation.x = 0.2; //Math.PI/15.7
		this.robot.hitBallMachineHandLeft.rotation.x = -0.9; //-Math.PI/3.49
		this.robot.hitBallMachineHandRight.rotation.x = -0.9; //-Math.PI/3.49
        this.board.mesh.position.y = 1.1; //Math.PI/2.85
        this.board.mesh.rotation.z = -0.75; //-Math.PI/4.18; //-0.75
    }
    else {
        this.robot.body.rotation.x = -0.2;
		this.robot.hitBallMachineHandLeft.rotation.x = 0.9;
		this.robot.hitBallMachineHandRight.rotation.x = 0.9;
        this.board.mesh.position.y = 1.1;
        this.board.mesh.rotation.z = 0.75;
    } 
}

player.prototype.set = function(){
    if(this.npc) {
        this.robot.body.rotation.x = 0;
    	this.robot.hitBallMachineHandLeft.rotation.x = -2.1;
    	this.robot.hitBallMachineHandRight.rotation.x = -2.1;
    	this.board.mesh.position.y = 2.05;
    	this.board.mesh.rotation.z = -0.75;
    }
    else {
    	this.robot.body.rotation.x = 0;
    	this.robot.hitBallMachineHandLeft.rotation.x = 2.1;
    	this.robot.hitBallMachineHandRight.rotation.x = 2.1;
    	this.board.mesh.position.y = 2.05;
    	this.board.mesh.rotation.z = 0.75;
    }
}

player.prototype.startServe = function (target) {
		this.serveTarget = target;
		this.startTime = clock.getElapsedTime();
    this.serveIsOn = true;
    this.state = 1;
}

player.prototype.startJump = function(target,jumpV,waitTime){
	this.state = 1;
	this.serveTarget = target;
	this.jumpServeIsOn = true;
	this.jumpIsOn = true;
	this.jumpStartTime = clock.getElapsedTime();
	this.jumpV = jumpV;//初速
	this.jumpWaitTime = waitTime;
}
player.prototype.serve = function(dT){
	this.normalServe(dT);
  this.jumpServe(dT);
}


player.prototype.normalServe = function(dT){
		if (this.serveIsOn === false) return;
		var now = clock.getElapsedTime();
    if(ball.isOn === false)//球跟著手
  		ball.mesh.position.copy(this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)));//NPC的話其實是左手
		
		if(this.serveState == 0){//如果現在不在Rest中就用BUMP狀態開始用加的
		 	this.serveAngleLeft = BUMP+ (now - this.startTime)*2 ;
		 	this.serveAngleRight = BUMP+ (now - this.startTime)*2*1.5;
		}
    else if(this.serveState == 1){//到Math.PI會迴轉所以從Math.PI開始減
    	this.serveAngleRight = Math.PI*1.3567- (now - this.startTime)*6;
    }
    else{
    	this.serveAngleLeft = Math.PI- (now - this.startTime)*6 ;
    	this.serveAngleRight = Math.PI- (now - this.startTime)*6 ;
    }
    
    
	if (this.serveState == 0 && this.serveAngleLeft > Math.PI){
		this.startTime = clock.getElapsedTime();
		this.serveState = 1;
	}
    if (this.serveState == 1 && this.serveAngleRight < Math.PI &&  ball.isOn === false){
      ball.isOn = true;
      this.passTarget(this.serveTarget);
      spikeSound.pause();
			spikeSound.currentTime = 0;
    	spikeSound.play();
      
      this.startTime = clock.getElapsedTime();
      this.serveState=2;
		}
    if(this.serveState == 2 && this.serveAngleLeft < BUMP){
    	this.serveAngleLeft = BUMP;
      this.serveAngleRight = BUMP;
      this.serveState = 0;
      this.serveIsOn = false;
      this.state = 2;///發完球變成stand by
      this.stateTarget = undefined;
    }
    /////////
    var gotTargetAngle = this.makeTargetAngle()/Math.PI*180%180;
    var robotY = this.robot.hitBallMachine.rotation.y/Math.PI*180%180;
      
    if(gotTargetAngle>robotY)
      	this.robot.hitBallMachine.rotation.y +=dT;
    else
      	this.robot.hitBallMachine.rotation.y -=dT;
    ////////////
    if(this.isLeft === true){
      this.robot.hitBallMachineHandLeft.rotation.x = -1*this.serveAngleRight;//-1反過來，左右手也是
      this.robot.hitBallMachineHandRight.rotation.x = -1*this.serveAngleLeft; 
    } 
    else{
    	this.robot.hitBallMachineHandLeft.rotation.x = this.serveAngleRight;
      this.robot.hitBallMachineHandRight.rotation.x = this.serveAngleLeft;  
    }
    
}

player.prototype.jumpServe = function(dT){//dT其實是傳給jump用的，發球動作是用jumpStartTime
	if (this.jumpServeIsOn === false) return;
	var now = clock.getElapsedTime();
    if(ball.isOn === false)//球跟著手
  		ball.mesh.position.copy(this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)));//NPC的話其實是左手
	if(this.jumpServeState == 0){
		this.serveAngleLeft = BUMP+ (now - this.jumpStartTime)*2 ;
		this.serveAngleRight = BUMP+ (now - this.jumpStartTime)*2*1.5;
	}
	if(this.jumpServeState == 3){
		this.serveAngleRight = Math.PI*1.3567- (now - this.jumpStartTime)*6;
	}
  if(this.jumpServeState == 4){
    this.serveAngleLeft = Math.PI- (now - this.jumpStartTime)*6 ;
    this.serveAngleRight = Math.PI- (now - this.jumpStartTime)*6 ;
  }

	if (this.jumpServeState == 0 && this.serveAngleLeft > Math.PI){
		this.jumpStartTime = clock.getElapsedTime();
		this.jumpServeState = 1;
		ball.isOn = true;
		ball.shoot(new THREE.Vector3(0, 5.5, 0));
	}
	if(this.jumpServeState == 1 && (now - this.jumpStartTime) > this.jumpWaitTime){
		this.jumpServeState = 2;
	}
	if(this.jumpServeState >= 2){
		this.jump(dT);
	}
	if(this.jumpServeState == 2){
		var ballY =  ball.mesh.position.y;
		var handY = this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)).y;
		if(Math.abs(ballY-handY)<0.85){
		  this.jumpServeState = 3;
		  this.jumpStartTime = clock.getElapsedTime();
		
		}
	}
	if(this.jumpServeState == 3 && this.serveAngleRight < Math.PI){
		this.jumpStartTime = clock.getElapsedTime();
		this.jumpServeState = 4;
		console.log("check");
		ball.isOn = true;
    this.passTarget(this.serveTarget);
    spikeSound.pause();
		spikeSound.currentTime = 0;
    spikeSound.play();
	}
  if(this.jumpServeState == 4 && this.serveAngleLeft < BUMP){
	  this.jumpServeState = 5;
  }
  if(this.jumpServeState == 5 &&  this.jumpIsOn === false){
    this.serveAngleLeft = BUMP;
    this.serveAngleRight = BUMP;
    this.jumpServeState = 0;
    this.jumpServeIsOn = false;
    this.state = 2;///發完球變成stand by
    this.stateTarget = undefined;
  }
    if(this.isLeft === true){
      this.robot.hitBallMachineHandLeft.rotation.x = -1*this.serveAngleRight;//-1反過來，左右手也是
      this.robot.hitBallMachineHandRight.rotation.x = -1*this.serveAngleLeft; 
    } 
    else{
    	this.robot.hitBallMachineHandLeft.rotation.x = this.serveAngleRight;
      this.robot.hitBallMachineHandRight.rotation.x = this.serveAngleLeft;  
    }
}


player.prototype.jump = function(dT){
  if (this.jumpIsOn === false) return;
  var f = new THREE.Vector3(0, -9.8, 0);
  var robotPos = new THREE.Vector3(0, 0, 0);
  this.jumpV.add ( f.clone().multiplyScalar(dT) );
  robotPos.copy(this.robot.hitBallMachine.position);
  robotPos.add ( this.jumpV.clone().multiplyScalar(dT) );
  this.robot.hitBallMachine.position.y = robotPos.y;
  if(this.jumpV.y<0){
	  //console.log(ball.mesh.position.y);
  }
  if(this.robot.hitBallMachine.position.y <= 0.39){
    this.robot.hitBallMachine.position.y = 0.4;
  	this.jumpIsOn=false; 
  } 
}

player.prototype.bisection = function(v0,theta,length,ys,ye){//predict bisection
	return (v0*Math.cos(theta)*(1*v0*Math.sin(theta)+Math.sqrt( v0*Math.sin(theta)*v0*Math.sin(theta) - 2*9.8*(ye-ys) ))-length*9.8);
}

player.prototype.predict = function(end){//傳進預測點end

	var predictTargetPos = new THREE.Vector3(0, 0, 0);
  predictTargetPos.copy(end); 
  /*
  end.y=ball.mesh.position.y;
  var predictTargetPos = new THREE.Vector3(0, 0, 0);
  predictTargetPos.copy(end); //為不改變end值，這邊複製給另外一個
  var length = predictTargetPos.sub(ball.mesh.position).length(); //計算目前位置跟預測點的水平距離
*/
  if(this.state===1 ){
      var theta = 25/180*Math.PI;
    }
    else if(this.state===5){
      var theta = 0;//-10/180*Math.PI;
    }
    else if(this.state===3 || this.state===9){
    	if(length < 2.5){
        var theta = 82.5/180*Math.PI;
      }
      else{
        var theta = 75/180*Math.PI;
      }
    }
    else{
      var theta = 60/180*Math.PI;
    }
    
    
  		var ballCopy  = new THREE.Vector3(0, 0, 0);
  		ballCopy.copy(ball.mesh.position);
      var ye = predictTargetPos.y;
      ballCopy.y=ye;
      
      length = predictTargetPos.sub(ballCopy).length();
      
      var ys = ball.mesh.position.y;
      var v0 = 0;
      
      var a = 0;
      var b = 50;
      var e = 0.0001;
      while(1){
      	var m = (a+b)/2;
        var fm = this.bisection(m,theta,length,ys,ye);
        var fa = this.bisection(a,theta,length,ys,ye);
        if(fm*fa<0)
        	b = m;
        else
        	a = m;
      	if((b-a)/2<e){
        	v0 = a;
        	break;
        }
      }
    end.y=ball.mesh.position.y;
  	var predictTargetTemp = new THREE.Vector3(0, 0, 0);
    predictTargetTemp.copy(end);
    var ballPos = new THREE.Vector3(0, 0, 0);
    ballPos.copy(ball.mesh.position);
    var temp3 = new THREE.Vector3(1, 0, 0);
    
    if(ball.mesh.position.z<end.z)
    	var phi = -1* temp3.angleTo(predictTargetTemp.sub(ballPos));
    else
    	var phi = 1* temp3.angleTo(predictTargetTemp.sub(ballPos));
    
    return [v0, theta, phi];
}

player.prototype.predictY = function(v0, theta, phi, ye){
  var ys = ball.mesh.position.y;
  var a = 4.9; // 9.8/2
  var b = -v0 * Math.sin(theta);
  var c = ye - ys;
  var t = (b*(-1) + Math.sqrt(Math.pow(b, 2) - 4*a*c)) / (2*a);
  
  var L = v0 * Math.cos(theta) * t;
  var movement = new THREE.Vector3(L, 0, 0);
  var axis = new THREE.Vector3( 0, 1, 0 );
  movement.applyAxisAngle(axis, phi);
  var finalP = new THREE.Vector3( 0, 0, 0 );
  finalP.addVectors(ball.mesh.position.clone(), movement);
  finalP.y = ye;
  
  return [finalP,t];
}

player.prototype.makeTarget = function(){
//npc判斷
	if(this.state === 4){
    var x = Math.random() * 5 + 2.5;
    var z = Math.random() * 7 - 3.5;
	var end = predictMesh.position.clone();
	end.y = 0;
    this.preTarget.copy(end);
    if(this.isLeft){
      if(x < 3) x++;
      if(x < 3.5) {
        if(z < 2 && z > -2) z = 2.5;
      }
      this.preTarget.set(x,0,z);
    }
  }
  else if(this.state === 5) {
	  var x = Math.random() * 3 + 4.5;
      var z = Math.random() * 6 - 3;
      if(x < 5.5) {
          	if(z < 3 && z > -3) {
            	if(z > 0) z = 3;
              else z = -3;
          }
      }
	  if(this.isLeft) {
		  this.preTarget.set(x,0,z);
      }
      else {
		var end = predictMesh.position.clone();
		end.y = 0;
		this.preTarget.copy(end);
      }
  }
}

player.prototype.makeTargetAngle = function(){
	var robotPosTemp = new THREE.Vector3(0, 0, 0);
  robotPosTemp.copy(this.robot.hitBallMachine.position);
  if(this.isLeft===false)
  	var temp = new THREE.Vector3(0, 0, -1);
  else
  	var temp = new THREE.Vector3(0, 0, 1);
  var targetTemp = new THREE.Vector3(0, 0, 0);
  if(this.state==3){
  	if(this.isLeft == true){
    	if(this.num === 1){
      	targetTemp.copy(npcPlayer2.robot.hitBallMachine.position);
  			var phi = 1* temp.angleTo(targetTemp.sub(robotPosTemp));
  			return  phi;
      }
      else{
      	targetTemp.copy(npcPlayer1.robot.hitBallMachine.position);
  			var phi = 1* temp.angleTo(targetTemp.sub(robotPosTemp));
  			return  phi;
      }
    }
    else{
    	if(this.num === 1){
      	targetTemp.copy(player2.robot.hitBallMachine.position);
  			var phi = 1* temp.angleTo(targetTemp.sub(robotPosTemp));
  			return  phi;
      }
      else{
      	targetTemp.copy(player1.robot.hitBallMachine.position);
  			var phi = 1* temp.angleTo(targetTemp.sub(robotPosTemp));
  			return  phi;
      }
    }
  	
  }
  
  else if(this.state === 1){
  	targetTemp.copy(this.serveTarget);
  	var phi = 1* temp.angleTo(targetTemp.sub(robotPosTemp));
  	return  phi;
  }
  else{
  	if(this.isLeft==false)
    	targetTemp.copy(predictMesh.position);
    else
  		targetTemp.copy(this.preTarget);
  	var phi = 1* temp.angleTo(targetTemp.sub(robotPosTemp));
  	return  phi;
  }
}
  
player.prototype.update = function(dT){
	if(player1.state === 0 && player2.state === 0 && npcPlayer1.state === 0 && npcPlayer2.state === 0) {
  	if(referee.whoServe === 1) {
    	referee.npcLastMode = 1;
    	referee.whoLastHit = 2;
    	referee.whoServe = 2;
			ball.isOn = false;
  		referee.playing = true;
  		var tmp = Math.random();
  		if(tmp > 0.5)
				npcPlayer1.startJump(new THREE.Vector3(5, 0, 0),new THREE.Vector3(0, 5, 0),0.1);  
  		else 
				npcPlayer1.startServe(new THREE.Vector3(5, 0, 0));
        
      player1.state = 2;
     	player2.state = 2;
     	npcPlayer2.state = 2;
    }
  	return;
  }
	if(this.state === 1){
  	this.serve(dT);
    return;//必要，不然會被下面的調整手臂洗掉機器人的手的位置
  }

	//if(this.state === 0 || this.state === 1) return;
  
  else if(this.state === 2){ //standBy
  	if(Math.abs(Math.PI/2-this.robot.hitBallMachine.rotation.y)>0.1){
      if(this.robot.hitBallMachine.rotation.y<Math.PI/2)
      	this.robot.hitBallMachine.rotation.y +=dT;
      else
      	this.robot.hitBallMachine.rotation.y -=dT;
    }
  	this.board.target.copy(this.standByPosition);
  	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
  	this.board.mesh.position.x = this.board.pos.x;
  	this.board.mesh.position.z = this.board.pos.z;
    if(this.npc) var frontOrBack = -0.8;
    else var frontOrBack = 0.8;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
    
    if(this.hitMode === 0) {
    	if(this.board.mesh.position.y > 1.1)
      	this.board.mesh.position.y -= 0.02;
        
      if(this.updateAngleLeft>BUMP){
    		this.updateAngleLeft -= dT * 3;
    		this.updateAngleRight -= dT * 3;
      }
    }
  }
  
  else if(this.state === 3){ //做球
  	var n = rotation(new THREE.Vector3(0, 1, 0), this.board.mesh.rotation.z, 0); //板子(手)的法線向量
		var p0 = this.board.mesh.localToWorld(new THREE.Vector3(0, -0.1, 0)); 
    // p0為板子(手)上的一點
    
    var distance = ball.mesh.position.clone().sub(this.board.mesh.localToWorld(new THREE.Vector3(0, 0.3, 0))).lengthSq(); //球與板子(手)的距離
    
    if(this.updateAngleRight <= Math.PI/1.3){
    	this.updateAngleLeft += dT*5;
    	this.updateAngleRight +=  dT*5;	
		}
    
    if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    //球運動到跟板子(手)同平面
    	var r = ball.mesh.position.clone().sub(p0);
      var r1 = r.clone().sub(n.clone().multiplyScalar(r.clone().dot(n))).lengthSq();
      if (Math.abs(r1) <= 0.16) { //球在板子(手)的範圍內      	
      	if(this.isLeft) {
        	referee.npcLastMode = 3;
        	referee.whoLastHit = 2;
          if(this.num === 1) var tmp = this.predict(new THREE.Vector3(-2, 0, 2)); //算出到(x, 0, z)的速度與角度
          else var tmp = this.predict(new THREE.Vector3(-2, 0, -2));
          var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2]));
  
          if(!(jumpTarget[1] < 2)) jumpTarget[1] = 1;
          if(this.num === 1) {
          	if(npcPlayer2.state === 6) {
            	npcPlayer2.state = 5; //殺球
      				npcPlayer2.chaseTarget = new THREE.Vector3(-2, 3.7, 2);
	  					npcPlayer2.jumpWaitTime = jumpTarget[1];
	  					npcPlayer2.jumpV = new THREE.Vector3(0, 5, 0);
	  					npcPlayer2.jumpIsOn = true;
              npcPlayer2.chaseTarget = jumpTarget[0];
							npcPlayer2.board.vel = new THREE.Vector3(0, 0, 0);
            }
          }
          else if(this.num === 2) {
          	if(npcPlayer1.state === 6) {
            	npcPlayer1.state = 5; //殺球
      				npcPlayer1.chaseTarget = new THREE.Vector3(-2, 3.7, -2);
	  					npcPlayer1.jumpWaitTime = jumpTarget[1];
	  					npcPlayer1.jumpV = new THREE.Vector3(0, 5, 0);
	  					npcPlayer1.jumpIsOn = true;
              npcPlayer1.chaseTarget = jumpTarget[0];
							npcPlayer1.board.vel = new THREE.Vector3(0, 0, 0);
            }
          }
        }
        else {
        	referee.playerLastMode = 3;
        	referee.whoLastHit = 1;
          if(this.num === 1) var tmp = this.predict(new THREE.Vector3(2, 0, 2)); //算出到(x, 0, z)的速度與角度
          else var tmp = this.predict(new THREE.Vector3(2, 0, -2));
          var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2]));
					if(!(jumpTarget[1] < 2)) jumpTarget[1] = 1;
          if(this.num === 1) {
          	if(player2.state === 6) {
            	player2.state = 5; //殺球
      				player2.chaseTarget = new THREE.Vector3(2, 3.7, 2);
	  					player2.jumpWaitTime = jumpTarget[1];
	  					player2.jumpV = new THREE.Vector3(0, 5, 0);
	  					player2.jumpIsOn = true;
              player2.chaseTarget = jumpTarget[0];
              player2.board.vel = new THREE.Vector3(0, 0, 0);
            }
          }
          else if(this.num === 2) {
          	if(player1.state === 6) {
            	player1.state = 5; //殺球
      				player1.chaseTarget = new THREE.Vector3(2, 3.7, -2);
	  					player1.jumpWaitTime = jumpTarget[1];
	  					player1.jumpV = new THREE.Vector3(0, 5, 0);
	  					player1.jumpIsOn = true;
              player1.chaseTarget = jumpTarget[0];
              player1.board.vel = new THREE.Vector3(0, 0, 0);
            }
          }
        }
    		slapSound.pause();
				slapSound.currentTime = 0;
    		slapSound.play();
      }
      this.state = 2;
      this.board.mesh.position.y = 1.1;
    }
    
  	//追落點
  	this.board.target.copy(this.chaseTarget);
  	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
  	this.board.mesh.position.x = this.board.pos.x;
    this.board.mesh.position.y = 2;
  	this.board.mesh.position.z = this.board.pos.z;
    if(this.npc) var frontOrBack = -0.9;
    else var frontOrBack = 0.9;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
  }
  
  
  else if(this.state === 4){ //normal attack
  	var n = rotation(new THREE.Vector3(0, 1, 0), this.board.mesh.rotation.z, 0); //板子(手)的法線向量
		var p0 = this.board.mesh.localToWorld(new THREE.Vector3(0, -0.1, 0)); 
    // p0為板子(手)上的一點
    var distance = ball.mesh.position.clone().sub(this.board.mesh.localToWorld(new THREE.Vector3(0, 0.3, 0))).lengthSq(); //球與板子(手)的距離
    
    if(distance < 3) { //球跟板子(手)距離小於3，手就開始往上揮
    	this.board.mesh.position.add(n.clone().multiplyScalar(dT*3));
    	this.updateAngleLeft += dT*3;
    	this.updateAngleRight +=  dT*3;
    
    }
    var robotPosTemp = new THREE.Vector3(0, 0, 0);
    robotPosTemp.copy(this.robot.hitBallMachine.position);
    if(robotPosTemp.sub(ball.mesh.position).length()<5 && this.preTarget.x==0 && this.preTarget.z==0){
    	this.makeTarget();
    }
    
    if(this.preTarget.x!=0 && this.preTarget.z!=0){
    	var gotTargetAngle = this.makeTargetAngle()/Math.PI*180%180;
      var robotY = this.robot.hitBallMachine.rotation.y/Math.PI*180%180;

      if(gotTargetAngle>robotY)
      	this.robot.hitBallMachine.rotation.y +=dT;
      else
      	this.robot.hitBallMachine.rotation.y -=dT;
    }
    
    if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    //球運動到跟板子(手)同平面
    	var r = ball.mesh.position.clone().sub(p0);
      var r1 = r.clone().sub(n.clone().multiplyScalar(r.clone().dot(n))).lengthSq();
      if (Math.abs(r1) <= 0.16) { //球在板子(手)的範圍內     
        if(this.isLeft) {  
        	referee.npcLastMode = 4;
          referee.whoLastHit = 2;
        	this.passTarget(this.preTarget);
          this.preTarget.set(0,0,0);
        }
        else {
        	referee.playerLastMode = 4;
        	referee.whoLastHit = 1;
        	this.passTarget(predictMesh.position.clone());
          this.preTarget.set(0,0,0);
        }
        this.state = 2;
        
        slapSound.pause();
				slapSound.currentTime = 0;
    		slapSound.play();
      }
      if(!this.isLeft){
      	if(playerCoach.isOne) this.state = 2;
      }
      else if(this.isLeft){
      	if(npcCoach.isOne) this.state = 2;
      }
    }
    
    //追落點
	this.board.target.copy(this.chaseTarget);
	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
	this.board.mesh.position.x = this.board.pos.x;
	this.board.mesh.position.z = this.board.pos.z;
	if(this.npc) var frontOrBack = -0.8;
	else var frontOrBack = 0.8;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
  
  
  
  }
  
  else if(this.state === 5){ //殺球
	
	this.jumpWaitTime -=dT;
	
	if(this.updateAngleRight <= Math.PI && this.jumpState === 0){
    	this.updateAngleLeft += dT*5;
    	this.updateAngleRight +=  dT*5;	
	}
	
  var robotPosTemp = new THREE.Vector3(0, 0, 0);
    robotPosTemp.copy(this.robot.hitBallMachine.position);
    if(robotPosTemp.sub(ball.mesh.position).length()<3 && this.preTarget.x==0 && this.preTarget.z==0){
    	this.makeTarget();
    }
    
    if(this.preTarget.x!=0 && this.preTarget.z!=0){
    	var gotTargetAngle = this.makeTargetAngle()/Math.PI*180%180;
      var robotY = this.robot.hitBallMachine.rotation.y/Math.PI*180%180;
      
      if(gotTargetAngle>robotY)
      	this.robot.hitBallMachine.rotation.y +=dT;
      else
      	this.robot.hitBallMachine.rotation.y -=dT;
    }
  
	if(this.jumpWaitTime<0 && this.jumpState === 0){
		  if(this.isLeft) {
      	referee.npcLastMode = 5;
      	referee.whoLastHit = 2;
        	this.passTarget(this.preTarget);
          this.preTarget.set(0,0,0);
      }
      else {
      	referee.playerLastMode = 5;
      	referee.whoLastHit = 1;
        this.passTarget(predictMesh.position.clone());
        this.preTarget.set(0,0,0);
      }
			this.jumpState = 1;
      spikeSound.pause();
			spikeSound.currentTime = 0;
    	spikeSound.play();
	}
	
	if(this.jumpIsOn == false){
		this.state = 2;
		this.jumpState = 0;
	}
	
	if(this.jumpWaitTime<0.7){
		this.jump(dT);
		
    	this.updateAngleLeft -= dT*3;
    	this.updateAngleRight -=  dT*3;	
	}
	else
		console.log("check wait");
	
	//追落點
	this.board.target.copy(this.chaseTarget);
	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
	this.board.mesh.position.x = this.board.pos.x;
	this.board.mesh.position.z = this.board.pos.z;
	if(this.npc) var frontOrBack = -0.8;
	else var frontOrBack = 0.8;	

	this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;

  }
  else if(this.state === 6){ //移動到殺球位置
  	//追落點
		this.board.target.copy(this.chaseTarget);
		this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
		this.board.mesh.position.x = this.board.pos.x;
		this.board.mesh.position.z = this.board.pos.z;
		if(this.npc) var frontOrBack = -0.8;
		else var frontOrBack = 0.8;	
	
		this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;
  }
  
  else if(this.state === 7){ //回到起始位置
  	//追落點
    if(referee.whoServe === 1) {
    	if(this.isLeft) {
    		if(this.num === 1) this.chaseTarget = new THREE.Vector3(-9, 1.1, 0);
      	else this.chaseTarget = this.standByPosition;
    	}
    	else {
    		if(this.num === 1) this.chaseTarget = this.standByPosition;
      	else this.chaseTarget = this.standByPosition;
    	}
    }
    else {
    	if(this.isLeft) {
    		if(this.num === 1) this.chaseTarget = this.standByPosition;
      	else this.chaseTarget = this.standByPosition;
    	}
    	else {
    		if(this.num === 1) this.chaseTarget = new THREE.Vector3(9, 1.1, 0);
      	else this.chaseTarget = this.standByPosition;
    	}
    }
		this.board.target.copy(this.chaseTarget);
		this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
		this.board.mesh.position.x = this.board.pos.x;
		this.board.mesh.position.z = this.board.pos.z;
		if(this.npc) var frontOrBack = -0.8;
		else var frontOrBack = 0.8;	
	
		this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;
  
  	//回到待機狀態
  	if(this.board.mesh.position.clone().sub(this.chaseTarget).length() < 1) {
    	this.board.vel = new THREE.Vector3(0, 0, 0);
    	this.state = 0;
    }
  }
  else if(this.state === 8){
    return;
  }
  else if(this.state === 9){ //做球
  	var n = rotation(new THREE.Vector3(0, 1, 0), this.board.mesh.rotation.z, 0); //板子(手)的法線向量
		var p0 = this.board.mesh.localToWorld(new THREE.Vector3(0, -0.1, 0)); 
    // p0為板子(手)上的一點
    
    var distance = ball.mesh.position.clone().sub(this.board.mesh.localToWorld(new THREE.Vector3(0, 0.3, 0))).lengthSq(); //球與板子(手)的距離
    
    if(distance < 3) { //球跟板子(手)距離小於3，手就開始往上揮
    	this.board.mesh.position.add(n.clone().multiplyScalar(dT*3));
    	this.updateAngleLeft += dT*3;
    	this.updateAngleRight +=  dT*3;
    
    }
    
    var gotTargetAngle = this.makeTargetAngle()/Math.PI*180%180;
    var robotY = this.robot.hitBallMachine.rotation.y/Math.PI*180%180;
    
    if(gotTargetAngle>robotY)
      this.robot.hitBallMachine.rotation.y +=dT;
    else
      this.robot.hitBallMachine.rotation.y -=dT;
      
    if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    //球運動到跟板子(手)同平面
    	var r = ball.mesh.position.clone().sub(p0);
      var r1 = r.clone().sub(n.clone().multiplyScalar(r.clone().dot(n))).lengthSq();
      if (Math.abs(r1) <= 0.16) { //球在板子(手)的範圍內      	
      	if(this.isLeft) {
        	referee.npcLastMode = 3;
        	referee.whoLastHit = 2;
          if(this.num === 1) var tmp = this.predict(new THREE.Vector3(-2, 0, 2)); //算出到(x, 0, z)的速度與角度
          else var tmp = this.predict(new THREE.Vector3(-2, 0, -2));
          var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2]));
  
          if(!(jumpTarget[1] < 2)) jumpTarget[1] = 1;
          if(this.num === 1) {
          	if(npcPlayer2.state === 6) {
            	npcPlayer2.state = 5; //殺球
      				npcPlayer2.chaseTarget = new THREE.Vector3(-2, 3.7, 2);
	  					npcPlayer2.jumpWaitTime = jumpTarget[1];
	  					npcPlayer2.jumpV = new THREE.Vector3(0, 5, 0);
	  					npcPlayer2.jumpIsOn = true;
              npcPlayer2.chaseTarget = jumpTarget[0];
							npcPlayer2.board.vel = new THREE.Vector3(0, 0, 0);
            }
          }
          else if(this.num === 2) {
          	if(npcPlayer1.state === 6) {
            	npcPlayer1.state = 5; //殺球
      				npcPlayer1.chaseTarget = new THREE.Vector3(-2, 3.7, -2);
	  					npcPlayer1.jumpWaitTime = jumpTarget[1];
	  					npcPlayer1.jumpV = new THREE.Vector3(0, 5, 0);
	  					npcPlayer1.jumpIsOn = true;
              npcPlayer1.chaseTarget = jumpTarget[0];
							npcPlayer1.board.vel = new THREE.Vector3(0, 0, 0);
            }
          }
        }
        else {
        	referee.playerLastMode = 3;
        	referee.whoLastHit = 1;
          if(this.num === 1) var tmp = this.predict(new THREE.Vector3(2, 0, 2)); //算出到(x, 0, z)的速度與角度
          else var tmp = this.predict(new THREE.Vector3(2, 0, -2));
          var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2]));
					if(!(jumpTarget[1] < 2)) jumpTarget[1] = 1;
          if(this.num === 1) {
          	if(player2.state === 6) {
            	player2.state = 5; //殺球
      				player2.chaseTarget = new THREE.Vector3(2, 3.7, 2);
	  					player2.jumpWaitTime = jumpTarget[1];
	  					player2.jumpV = new THREE.Vector3(0, 5, 0);
	  					player2.jumpIsOn = true;
              player2.chaseTarget = jumpTarget[0];
              player2.board.vel = new THREE.Vector3(0, 0, 0);
            }
          }
          else if(this.num === 2) {
          	if(player1.state === 6) {
            	player1.state = 5; //殺球
      				player1.chaseTarget = new THREE.Vector3(2, 3.7, -2);
	  					player1.jumpWaitTime = jumpTarget[1];
	  					player1.jumpV = new THREE.Vector3(0, 5, 0);
	  					player1.jumpIsOn = true;
              player1.chaseTarget = jumpTarget[0];
              player1.board.vel = new THREE.Vector3(0, 0, 0);
            }
          }
        }
    		slapSound.pause();
				slapSound.currentTime = 0;
    		slapSound.play();
      }
      this.state = 2;
    }
    
  	//追落點
  	this.board.target.copy(this.chaseTarget);
  	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
  	this.board.mesh.position.x = this.board.pos.x;
  	this.board.mesh.position.z = this.board.pos.z;
    if(this.npc) var frontOrBack = -0.9;
    else var frontOrBack = 0.9;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
  }
  
  //實際改robot的數值
  
  if(this.isLeft === true){
    this.robot.hitBallMachineHandLeft.rotation.x = -1*this.updateAngleRight;//-1反過來，左右手也是
    this.robot.hitBallMachineHandRight.rotation.x = -1*this.updateAngleLeft; 
    
  } 
  else{
    this.robot.hitBallMachineHandLeft.rotation.x = this.updateAngleRight;
    this.robot.hitBallMachineHandRight.rotation.x = this.updateAngleLeft;  
  }
  
}


player.prototype.passTarget = function(end){
  var tmp = this.predict(end); //算出到(x, 0, z)的速度與角度
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2])); //將球射出去
  var bumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 1.1); //算出球運動到y=1.1時的位置
  var setTarget = this.predictY(tmp[0], tmp[1], tmp[2], 2);
  var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  var groundTarget = this.predictY(tmp[0], tmp[1], tmp[2], 0.2);
  //將y=1.1時的位置傳給對場的coach
  if(this.isLeft) {
  	playerCoach.isOn = true;
    playerCoach.groundTarget = groundTarget[0];
  	playerCoach.bumpTarget = bumpTarget[0];
    playerCoach.setTarget = setTarget[0];
		playerCoach.jumpTarget = jumpTarget[0];
		playerCoach.jumpTime = jumpTarget[1];
	
  }
  else {
   	npcCoach.isOn = true;
    npcCoach.groundTarget = groundTarget[0];
  	npcCoach.bumpTarget = bumpTarget[0];
    npcCoach.setTarget = setTarget[0];
  	npcCoach.jumpTarget = jumpTarget[0];
		npcCoach.jumpTime = jumpTarget[1];
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////

var scene = new THREE.Scene();
var renderer, camera, controls;
var basicScene = new BasicScene (scene);
var linesPerson = new linesPerson();
var ball = new Ball (scene);
var clock = new THREE.Clock();
var referee = new referee();
var keyboard = new KeyboardState();
var attackPosRange = 1; //0:left 1:mid 2:right
var attackRangeLine, pass = true, spike = false;
var SpriteText2D = THREE_Text.SpriteText2D;
var textAlign = THREE_Text.textAlign;
var slapSound, spikeSound;
var raycaster;
var mouse = new THREE.Vector2();
var pickables = [];
var predictMesh;
var buttonLight = 0, countLight = 0;
var nPoint = 0, pPoint = 0;
var npcPointTen, npcPointOne, playerPointTen, playerPointOne;
var playerPoint1, playerPoint2, npcPoint1, npcPoint2;
var nptAngle = 0, npoAngle = 0, pptAngle = 0, ppoAngle = 0;
var nptPic = 10, npoPic = 10, pptPic = 10, ppoPic = 10;
var nptWaitT = 0, npoWaitT = 0, pptWaitT = 0, ppoWaitT = 0;

$("#pass").click(function() {
	pass = !pass;
  $("#pass").toggleClass("btn-active");
});

$("#spike").click(function() {
	spike = !spike;
  $("#spike").toggleClass("btn-active");
});
$('#start').click(function() {
	referee.whoLastHit = 1;
	if(player1.state === 0) {
		referee.whoServe = 1;
		ball.isOn = false;
  	referee.playing = true;
  
  	var tmp  = predictMesh.position.clone();
	tmp.y = 0;
  	if(spike) {
		player1.startJump(tmp,new THREE.Vector3(0, 5, 0),0.1);  
    }
  	else {
		player1.startServe(tmp);
    }
      
     player2.state = 2;
     npcPlayer1.state = 2;
     npcPlayer2.state = 2;
  }
});

init();
animate();

function init() {
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(16.5, 7, 0);
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  
  //點擊落點
  attackCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  attackCamera.position.set(30, 0, 0);
  attackControls = new THREE.OrbitControls(attackCamera, renderer.domElement);
  cameraHUD = new THREE.OrthographicCamera(-10, 10, 10, -10, -1, 1000);
  cameraHUD.position.z = 0;
  
  renderer.autoClear = false;
  sceneHUD = new THREE.Scene();
  
  //不同view的HUD
var fframe = new THREE.Mesh(new THREE.PlaneGeometry(5.1, 0.08), new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false
  }));
var fframe2 = new THREE.Mesh(new THREE.PlaneGeometry(6.3, 0.08), new THREE.MeshBasicMaterial({
    color: 0xff0000,
    opacity: 0.6,
    transparent: true,
    depthTest: false
  }));
  var fup = fframe.clone();
  fup.position.set (7.3,-3.4,0);
  var fdown = fframe.clone();
  fdown.position.set (7.3,-9.68,0);
  var fleft = fframe2.clone();
  fleft.rotation.z = Math.PI/2;
  fleft.position.set (4.77,-6.6,0);
  var fright = fframe2.clone();
  fright.rotation.z = Math.PI/2;
  fright.position.set (9.83,-6.6,0);
  sceneHUD.add(fup);
  sceneHUD.add(fdown);
  sceneHUD.add(fleft);
  sceneHUD.add(fright);
  
  npcCoach = new coach(1);
  playerCoach = new coach(0);
  
  npcPlayer1 = new player(1, 1);  
  npcPlayer1.board.mesh.position.set(-3, 1.1, -1.8);
 npcPlayer1.robot.hitBallMachine.position.set(npcPlayer1.board.mesh.position.x-0.8, 0.4, npcPlayer1.board.mesh.position.z);
  npcPlayer1.standByPosition = new THREE.Vector3(-3, 1.1, -1.8);
  npcPlayer1.isLeft = true;
  
  npcPlayer2 = new player(1, 2);  
  npcPlayer2.board.mesh.position.set(-4, 1.1, 1.8);
 npcPlayer2.robot.hitBallMachine.position.set(npcPlayer2.board.mesh.position.x-0.8, 0.4, npcPlayer2.board.mesh.position.z);
  npcPlayer2.standByPosition = new THREE.Vector3(-4, 1.1, 1.8);
  npcPlayer2.isLeft = true;
  
  player1 = new player(0, 1);  
  player1.board.mesh.position.set(9, 1.1, 0);
 player1.robot.hitBallMachine.position.set(player1.board.mesh.position.x+0.8, 0.4, player1.board.mesh.position.z);
 player1.standByPosition = new THREE.Vector3(4, 1.1, -1.8);

 	player2 = new player(0, 2);  
  player2.board.mesh.position.set(3, 1.1, 1.8);
 player2.robot.hitBallMachine.position.set(player2.board.mesh.position.x+0.8, 0.4, player2.board.mesh.position.z);
 	player2.standByPosition = new THREE.Vector3(3, 1.1, 1.8);
  
  	predictMesh = new THREE.Mesh(new THREE.CylinderGeometry( 0.05, 0.25, 0.6, 5 ), new THREE.MeshLambertMaterial({color: 0xff0000, transparent: true, 
                         side:THREE.DoubleSide}));
  predictMesh.rotation.x = Math.PI;    
  predictMesh.position.set(-4, 0.3, 1);
 	scene.add(predictMesh);	
  
  //記分板
  	var scoreBoard = new THREE.Object3D();
    scoreBoard.position.set(0, 0, -6.5);
    scoreBoard.rotation.y = 1.3;
    scene.add(scoreBoard);
    var geometry = new THREE.CylinderGeometry( 0.1, 0.1, 2, 32 );
		var material = new THREE.MeshLambertMaterial( {color: 0x285fdd} );
		var bottom = new THREE.Mesh( geometry, material );
  	bottom.rotation.z = Math.PI/2;
  	bottom.position.set(0, 0.3, -0.5);
		scoreBoard.add( bottom ); 
    var bottom2 = bottom.clone();
    bottom2.position.set(0, 0.3, 0.5);
    scoreBoard.add( bottom2 ); 
    var bottom3 = new THREE.Mesh( new THREE.CylinderGeometry( 0.15, 0.15, 0.3, 32 ), new THREE.MeshLambertMaterial( {color: 0x000000} ) );
    bottom3.position.set(1, 0.3, 0.5);
    bottom3.rotation.z = Math.PI/2;
    scoreBoard.add( bottom3 ); 
    var bottom4 = bottom3.clone();
    bottom4.position.set(1, 0.3, -0.5);
    scoreBoard.add( bottom4 ); 
    var bottom5 = bottom3.clone();
    bottom5.position.set(-1, 0.3, 0.5);
    scoreBoard.add( bottom5 ); 
    var bottom6 = bottom3.clone();
    bottom6.position.set(-1, 0.3, -0.5);
    scoreBoard.add( bottom6 ); 
    var middle = new THREE.Mesh( new THREE.CylinderGeometry( 0.07, 0.07, 1.2, 32 ), new THREE.MeshLambertMaterial( {color: 0x804000} ) );
    middle.position.set(0, 0.8, 0.3);
    middle.rotation.x = -0.45;
    scoreBoard.add( middle ); 
    var middle2 = middle.clone();
    middle2.position.set(0, 0.8, -0.3);
    middle2.rotation.x = 0.45;
    scoreBoard.add( middle2 ); 
    var middle3 = new THREE.Mesh( new THREE.CylinderGeometry( 0.08, 0.08, 1.8, 32 ), new THREE.MeshLambertMaterial( {color: 0x927e39} ) );
    middle3.position.set(0, 2.2, 0);
    scoreBoard.add( middle3 ); 
    var top = new THREE.Mesh( new THREE.CylinderGeometry( 0.08, 0.08, 2.8, 32 ), new THREE.MeshLambertMaterial( {color: 0xc9bb40} ) );
    top.position.set(0, 3.1, 0);
    top.rotation.z = Math.PI/2;
    scoreBoard.add( top ); 
    var npcBoard = new THREE.Mesh( new THREE.PlaneGeometry( 1.3, 0.5, 32 ), new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/eMkFej9.png'),  side:THREE.DoubleSide}) );
    npcBoard.position.set(-0.7, 1.7, 0);
    scoreBoard.add(npcBoard ); 
    var youBoard = new THREE.Mesh( new THREE.PlaneGeometry( 1.3, 0.5, 32 ), new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/wGSYvnr.png'),  side:THREE.DoubleSide}) );
    youBoard.position.set(0.7, 1.7, 0);
    scoreBoard.add(youBoard ); 
    
    npcPointTen = new THREE.Object3D();
    npcPointTen.position.set(-1.05, 3.1, 0);
    THREE.ImageUtils.crossOrigin = '';
		var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/wymDw47.png'),  side:THREE.DoubleSide});
    npcPoint1 = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), material );
    npcPointTen.add(npcPoint1);
    npcPoint1.position.set(0, -0.55, 0.01);
    var npcPointback1 = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), new THREE.MeshBasicMaterial ({color: 0xffffff,  side:THREE.DoubleSide} ));
    npcPointTen.add(npcPointback1);
    npcPointback1.position.set(0, -0.55, -0.01);
    scoreBoard.add(npcPointTen);
    
    npcPointOne = new THREE.Object3D();
    npcPointOne.position.set(-0.4, 3.1, 0);
    npcPoint2 = npcPoint1.clone();
    npcPointOne.add(npcPoint2);
    npcPoint2.position.set(0, -0.55, 0.01);
    var npcPointback2 = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), new THREE.MeshBasicMaterial ({color: 0xffffff,  side:THREE.DoubleSide} ));
    npcPointOne.add(npcPointback2);
    npcPointback2.position.set(0, -0.55, -0.01);
    scoreBoard.add(npcPointOne);
    
    playerPointTen = new THREE.Object3D();
    playerPointTen.position.set(0.4, 3.1, 0);
    material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/8kte6xE.png'),  side:THREE.DoubleSide});
    playerPoint1 = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), material );
    playerPointTen.add(playerPoint1);
    playerPoint1.position.set(0, -0.55, 0.01);
    var playerPointback1 = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), new THREE.MeshBasicMaterial ({color: 0xffffff,  side:THREE.DoubleSide} ));
    playerPointTen.add(playerPointback1);
    playerPointback1.position.set(0, -0.55, -0.01);
    scoreBoard.add(playerPointTen);
    
    playerPointOne = new THREE.Object3D();
    playerPointOne.position.set(1.05, 3.1, 0);
    playerPoint2 = playerPoint1.clone();
    playerPointOne.add(playerPoint2);
    playerPoint2.position.set(0, -0.55, 0.01);
    var playerPointback2 = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), new THREE.MeshBasicMaterial ({color: 0xffffff,  side:THREE.DoubleSide} ));
    playerPointOne.add(playerPointback2);
    playerPointback2.position.set(0, -0.55, -0.01);
    scoreBoard.add(playerPointOne);
  
  slapSound = document.getElementById ('slapSound');
  slapSound.volume = 1.0;
  spikeSound = document.getElementById ('spikeSound');
  spikeSound.volume = 1.0;
  
  pickables.push(basicScene.floor);
  raycaster = new THREE.Raycaster();
  document.addEventListener('mousedown', onDocumentMouseDown, false);
  
  window.addEventListener('resize', onWindowResize, false);
  window.performance = window.performance || Date;
}

function onDocumentMouseDown(event) {

  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
console.log("x : " + mouse.x + ", y : " + mouse.y);
	if(mouse.x >= 0.65 && mouse.x <= 0.837 && mouse.y <= -0.4 && mouse.y >= -0.84 ) {
	
  	var x = (mouse.x-0.65) / (0.837 - 0.65);
    x = 3 - x * 6;
    var y = (mouse.y+0.84) / (0.84 - 0.4);
    y = -1.6 - y * 5.5;
    predictMesh.position.set(y, 0.3, x);
  }
}

function rotationPoint(obj3D, plane, angle, pic, who) {
  if(who === 1) {
  	if((clock.getElapsedTime() - nptWaitT) < 0) return;
  }
  else if(who === 2) {
  	if((clock.getElapsedTime() - npoWaitT) < 0) return;
  }
  else if(who === 3) {
  	if((clock.getElapsedTime() - pptWaitT) < 0) return;
  }
  else {
  	if((clock.getElapsedTime() - ppoWaitT) < 0) return;
  }
  
  
	if(angle > 0) {
  	if(angle <= Math.PI ) {
    	if(pic != 10) {
    		THREE.ImageUtils.crossOrigin = '';
        if(pic === 0) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/wymDw47.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/8kte6xE.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 1) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/HMgzB7H.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/8AusPQF.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 2) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/g5ENXGp.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/YIotKIY.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 3) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/MClxbG0.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/AA78hBK.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 4) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/x0Fkovx.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/CeBJEGv.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 5) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/llXH3eP.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/e8UbrHv.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 6) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/DcpKWp4.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/8qU0ODi.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 7) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/upFCUSk.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/voGh3Ll.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 8) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/eZElsTg.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/bkRwsBy.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 9) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/y2rLsGB.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/OAUHYyq.png'),  side:THREE.DoubleSide});
          }
        }
        if(who === 1) {
        	nptWaitT = 0.5 + clock.getElapsedTime();
          nptPic = 10;
        }
        else if(who === 2) {
        	npoWaitT = 0.5 + clock.getElapsedTime();
          npoPic = 10;
        }
        else if(who === 3) {
        	pptWaitT = 0.5 + clock.getElapsedTime();
          pptPic = 10;
        }
        else {
        	ppoWaitT = 0.5 + clock.getElapsedTime();
          ppoPic = 10;
        }
    		plane = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), material );
    		obj3D.add(plane);
    		plane.position.set(0, -0.55, 0.01);
        pic = 10;
      }
    }
    obj3D.rotation.y -= 0.1;
    if(who === 1) {
    	nptAngle -= 0.1;
      if(nptAngle <= 0) nptAngle = 0;
    }
    else if(who === 2) {
    	npoAngle -= 0.1;
      if(npoAngle <= 0) npoAngle = 0;
    }
    else if(who === 3) {
    	pptAngle -= 0.1;
      if(pptAngle <= 0) pptAngle = 0;
    }
    else {
    	ppoAngle -= 0.1;
      if(ppoAngle <= 0) ppoAngle = 0;
    }
    
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  attackCamera.aspect = window.innerWidth / window.innerHeight;
  attackCamera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	attackCamera.lookAt(new THREE.Vector3(-3.6, 0, 0));
	attackCamera.position.set(-3.5, 10, 0);
	renderer.clear(true);
  controls.update();
  attackControls.update();
  keyboard.update();
  
  var dT = clock.getDelta();
  referee.update();
  linesPerson.update();
  ball.update(dT);
  npcCoach.update();
  playerCoach.update();
  npcPlayer1.update(dT);
  npcPlayer2.update(dT);
  player1.update(dT);
  player2.update(dT);
  
  npcPlayer1.jumpServe(dT);
  
  predictMesh.rotation.y += 0.03;
  
  //point
  rotationPoint(npcPointTen, npcPoint1, nptAngle, nptPic, 1);
  rotationPoint(npcPointOne, npcPoint2, npoAngle, npoPic, 2);
  rotationPoint(playerPointTen, playerPoint1, pptAngle, pptPic, 3);
  rotationPoint(playerPointOne, playerPoint2, ppoAngle, ppoPic, 4);
  
  if(referee.whoServe === 2) {
  	var tmp = buttonLight - clock.getElapsedTime();
  	if(player1.state === 0 && tmp < 0) {
  		$("#start").toggleClass("btn-active");
      buttonLight = clock.getElapsedTime() + 0.5;
      countLight ++;
    }
  }
  else {
  	if(countLight % 2 === 1) {
    	$("#start").toggleClass("btn-active");
      countLight = 0;
    }
  }
  
  if(referee.startCount) {
  	referee.restartCount -= dT;
    if(referee.restartCount <= 0) {
    	 referee.restartCount = 2;
        referee.startCount = false;
        ball.isOn = false;
        linesPerson.isOn = false;
        linesPerson.inOrOut = 0;
        linesPerson.hitBallMachineHandRight.rotation.x = 0;
        referee.resetPlayerPosition();
    }
  }
  
  //攻擊點操作
    if (keyboard.pressed("up")) {
  	if (predictMesh.position.x > -7.3) predictMesh.position.x -= 0.1; 
  } if (keyboard.pressed("down")) {
  	if (predictMesh.position.x < -1) predictMesh.position.x += 0.1; 
  } if (keyboard.pressed("left")) {
		if (predictMesh.position.z < 3.5) predictMesh.position.z += 0.1; 
  } if (keyboard.pressed("right")) {
		if (predictMesh.position.z > -3.5) predictMesh.position.z -= 0.1;
  } 
  
  //狀態顯示
  if(npcPlayer1.state === 0) npcPlayer1.sprite.text = "ready";
  else if(npcPlayer1.state === 1) npcPlayer1.sprite.text = "serve";
  else if(npcPlayer1.state === 2) npcPlayer1.sprite.text = "stand by";
  else if(npcPlayer1.state === 3) npcPlayer1.sprite.text = "pass";
  else if(npcPlayer1.state === 4) npcPlayer1.sprite.text = "bump";
  else if(npcPlayer1.state === 5) npcPlayer1.sprite.text = "spike";
  else if(npcPlayer1.state === 6) npcPlayer1.sprite.text = "spike";
  else if(npcPlayer1.state === 8) npcPlayer1.sprite.text = "waiting";
  else if(npcPlayer1.state === 9) npcPlayer1.sprite.text = "pass";
  
  if(npcPlayer2.state === 0) npcPlayer2.sprite.text = "ready";
  else if(npcPlayer2.state === 1) npcPlayer2.sprite.text = "serve";
  else if(npcPlayer2.state === 2) npcPlayer2.sprite.text = "stand by";
  else if(npcPlayer2.state === 3) npcPlayer2.sprite.text = "pass";
  else if(npcPlayer2.state === 4) npcPlayer2.sprite.text = "bump";
  else if(npcPlayer2.state === 5) npcPlayer2.sprite.text = "spike";
  else if(npcPlayer2.state === 6) npcPlayer2.sprite.text = "spike";
  else if(npcPlayer2.state === 8) npcPlayer2.sprite.text = "waiting";
  else if(npcPlayer2.state === 9) npcPlayer2.sprite.text = "pass";
  
  if(player1.state === 0) player1.sprite.text = "ready";
  else if(player1.state === 1) player1.sprite.text = "serve";
  else if(player1.state === 2) player1.sprite.text = "stand by";
  else if(player1.state === 3) player1.sprite.text = "pass";
  else if(player1.state === 4) player1.sprite.text = "bump";
  else if(player1.state === 5) player1.sprite.text = "spike";
  else if(player1.state === 6) player1.sprite.text = "spike";
  else if(player1.state === 8) player1.sprite.text = "waiting";
  else if(player1.state === 9) player1.sprite.text = "pass";
  
  if(player2.state === 0) player2.sprite.text = "ready";
  else if(player2.state === 1) player2.sprite.text = "serve";
  else if(player2.state === 2) player2.sprite.text = "stand by";
  else if(player2.state === 3) player2.sprite.text = "pass";
  else if(player2.state === 4) player2.sprite.text = "bump";
  else if(player2.state === 5) player2.sprite.text = "spike";
  else if(player2.state === 6) player2.sprite.text = "spike";
  else if(player2.state === 8) player2.sprite.text = "waiting";
  else if(player2.state === 9) player2.sprite.text = "pass";
  
  player1.sprite.position.copy(player1.robot.hitBallMachine.position);
  player1.sprite.position.x -= 0.5;
  player1.sprite.position.y += 2;
  player2.sprite.position.copy(player2.robot.hitBallMachine.position);
  player2.sprite.position.x -= 0.5;
  player2.sprite.position.y += 2;
  npcPlayer1.sprite.position.copy(npcPlayer1.robot.hitBallMachine.position);
  npcPlayer1.sprite.position.x += 0.5;
  npcPlayer1.sprite.position.y += 2;
  npcPlayer2.sprite.position.copy(npcPlayer2.robot.hitBallMachine.position);
  npcPlayer2.sprite.position.x += 0.5;
  npcPlayer2.sprite.position.y += 2;

  attackCamera.lookAt(new THREE.Vector3(-3.6, 0, 0));
	attackCamera.position.set(-3.5, 10, 0);
  requestAnimationFrame(animate);
  render();
}

function render() {
  var WW = window.innerWidth;
  var HH = window.innerHeight;
	renderer.setScissorTest(true);

	renderer.setViewport(0, 0, WW, HH);
  renderer.setScissor(0, 0, WW, HH);
  renderer.clear();
  renderer.render(scene, camera);
  
  attackCamera.lookAt(new THREE.Vector3(-3.6, 0, 0));
	attackCamera.position.set(-3.5, 10, 0);
  renderer.render(sceneHUD, cameraHUD);
  renderer.setViewport(WW/1.35, HH/60, WW/4, HH/3.2);
  renderer.setScissor(WW/1.35, HH/60, WW/4, HH/3.2);
  renderer.clear();
  attackCamera.aspect = window.innerWidth / window.innerHeight;
  attackCamera.updateProjectionMatrix();
  renderer.render(scene, attackCamera);
  
  renderer.setScissorTest(false);
}

window.focus();
</script>
</body>

</html>