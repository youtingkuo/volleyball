<html><head>
<style>
#info {
  position: absolute;
  top: 2%;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}

.pass {
  position: absolute;
  border-radius: 50px;
  left : 6%;
  top: 77%;
  width: 80px;
  height: 80px;
  background-image: url(https://i.imgur.com/OVO20Sn.png);
  background-size: cover;
  transition: all 0.5s;
}

.pass.btn-active {
  background-image: url(https://i.imgur.com/uewilpE.png);
}

.spike {
  position: absolute;
  border-radius: 50px;
  left : 13%;
  top: 77%;
  width: 80px;
  height: 80px;
  background-image: url(https://i.imgur.com/ehUlaMl.png);
  background-size: cover;
  transition: all 0.5s;
}

.spike.btn-active {
  background-image: url(https://i.imgur.com/fDoF6E1.png);
}

.start {
  position: absolute;
  border-radius: 50px;
  left : 20%;
  top: 77%;
  width: 80px;
  height: 80px;
  background-image: url(https://i.imgur.com/4jtk3xp.png);
  background-size: cover;
  transition: all 0.5s;
}

.start.btn-active {
  background-color:#ffff00;
}


</style>
</head>

<body> 
<div id="info"></div>
<button id='pass' class='pass'></button>
<button id='spike' class='spike' ></button>
<button id='start' class='start'></button>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://rawgit.com/jyunming-chen/tutsplus/master/js/text2D.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<audio id="soundtrack" autoplay loop style="display:none">
</audio>
<audio id="slapSound" style="display:none">
<source src="https://youtingkuo.github.io/sound/slap.mp3" type='audio/mp3'>
</audio>
<audio id="spikeSound" style="display:none">
<source src="https://youtingkuo.github.io/sound/spike.mp3" type='audio/mp3'>
</audio>


<script>
var BasicScene = function (scene){
    var light1 = new THREE.PointLight();
    light1.position.set(0, 5, -8);
    scene.add(light1);
    var light2 = new THREE.PointLight();
    light2.position.set(0, 5, 8);
    scene.add(light2);
    var light3 = new THREE.PointLight();
    light3.position.set(-13, 3, 0);
    scene.add(light3);
    var light4 = new THREE.PointLight();
    light4.position.set(13, 3, 0);
    scene.add(light4);
      
    THREE.ImageUtils.crossOrigin = '';
    var geometry = new THREE.CylinderGeometry( 50, 50, 50, 32, 32 );
		var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/fJxaqVc.jpg'),  side:THREE.DoubleSide});
		var cylinder = new THREE.Mesh( geometry, material );
    cylinder.position.y = 12.5;
		scene.add( cylinder );
	
  	var texture = THREE.ImageUtils.loadTexture('https://i.imgur.com/uLAXfWL.jpg');
  
	this.floor = new THREE.Mesh(new THREE.PlaneBufferGeometry(32,16,32), new THREE.MeshBasicMaterial({map: texture, 
                         transparent: true, 
                         side:THREE.DoubleSide}));
	this.floor.rotation.x=-Math.PI/2;
	scene.add(this.floor);
  
	texture = THREE.ImageUtils.loadTexture('https://i.imgur.com/r7rjUNg.jpg');
	this.ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(100,100,32), new THREE.MeshBasicMaterial({map: texture, 
                         transparent: true, 
                         side:THREE.DoubleSide}));
	this.ground.position.y -= 0.02;
	this.ground.rotation.x=-Math.PI/2;
	scene.add(this.ground);

	this.line1 = new THREE.Mesh(new THREE.PlaneBufferGeometry(16,0.125,32), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color: 0xffffff}));
	this.line1.rotation.x=-Math.PI/2;
	this.line1.position.set(0, 0.05, 4.0625);
	scene.add(this.line1);
	this.line2 = this.line1.clone();
	this.line2.position.set(0, 0.05, -4.0625);
	scene.add(this.line2);
	this.line3 = new THREE.Mesh(new THREE.PlaneBufferGeometry(8.25,0.125,32), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color: 0xffffff}));
	this.line3.rotation.x=-Math.PI/2;
	this.line3.rotation.z=-Math.PI/2;
	this.line3.position.set(-8.0625, 0.05, 0);
	scene.add(this.line3);
	this.line4 = this.line3.clone();
	this.line4.position.set(8.0625, 0.05, 0);
	scene.add(this.line4);
	
	var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,2.55,32),new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color: 0xffffff}));
  	var cylinder2 = cylinder.clone();
  	cylinder.position.set(0,2.55/2,4.1);
  	cylinder2.position.set(0,2.55/2,-4.1);
  	scene.add(cylinder);
  	scene.add(cylinder2);
  
  	texture = THREE.ImageUtils.loadTexture('https://i.imgur.com/xqMo1dt.png');
  	var net = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.8,8,32),new THREE.MeshBasicMaterial({map: texture, 
                         transparent: true, 
                         opacity :0.15,
                         side:THREE.DoubleSide})); 
  	net.position.set(0,1.93,0);
  	net.rotation.z=Math.PI/2;
  	net.rotation.y=Math.PI/2;
  	scene.add(net);
    var netTop = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.08,8,32), new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color: 0xffffff}));
    netTop.position.set(0,2.37,0);
  	netTop.rotation.z=Math.PI/2;
  	netTop.rotation.y=Math.PI/2;
  	scene.add(netTop);
    var netBottom = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.08,8,32), new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color: 0xffffff}));
    netBottom.position.set(0,1.49,0);
  	netBottom.rotation.z=Math.PI/2;
  	netBottom.rotation.y=Math.PI/2;
  	scene.add(netBottom);
};

///////////////////////////////////////////////////////////////////////////
var Ball = function (scene){
  this.v = new THREE.Vector3(0, 0, 0);
  this.angle = 0;
  this.isOn = false;
  
  THREE.ImageUtils.crossOrigin = '';
  var texture =
  THREE.ImageUtils.loadTexture('https://i.imgur.com/vSpU7ik.png');
  
	this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({map: texture, 
                         transparent: true, 
                         side:THREE.DoubleSide}));
  this.mesh.position.set(0, 0.2, 0);
 	scene.add(this.mesh);
  
  this.start = function () {
    this.isOn = true;
  };
  
  this.update = function(dT) {
  	if (this.isOn === false) return;
	
  	var f = new THREE.Vector3(0, -9.8, 0);
    this.v.add ( f.clone().multiplyScalar(dT) );
  	this.mesh.position.add ( this.v.clone().multiplyScalar(dT) );
    this.mesh.rotation.z += 0.03; 
    
    this.netCollisionDetection();
    
    var n = new THREE.Vector3(0, 1, 0);
		var p0 = new THREE.Vector3(0, 0.2, 0); 
    	
		if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    	if(referee.whoLastHit != 0) {
    		player1.board.vel = new THREE.Vector3(0, 0, 0);
    		player2.board.vel = new THREE.Vector3(0, 0, 0);
    		npcPlayer1.board.vel = new THREE.Vector3(0, 0, 0);
    		npcPlayer2.board.vel = new THREE.Vector3(0, 0, 0);
   	 	}
    	if(referee.whoLastHit === 1) {
      	if(this.mesh.position.x > -8 && this.mesh.position.x < 0 && this.mesh.position.z < 4 && this.mesh.position.z > -4) {
        	referee.rHandUp = true;
          referee.whoServe = 2;
          pPoint++;
          ppoAngle = Math.PI*2;
          ppoPic = pPoint%10;
          if(ppoPic === 0) {
          	pptAngle = Math.PI*2;
            pptPic = pPoint/10;
          }
        }
        else {
      		referee.lHandUp = true;
          referee.whoServe = 1;
          nPoint++;
          npoAngle = Math.PI*2;
          npoPic = nPoint%10;
          if(npoPic === 0) {
          	nptAngle = Math.PI*2;
            nptPic = nPoint/10;
          }
        }
        referee.whoLastHit = 0;
      }
      else if(referee.whoLastHit === 2) {
      	if(this.mesh.position.x < 8 && this.mesh.position.x > 0 && this.mesh.position.z < 4 && this.mesh.position.z > -4) {
        	referee.lHandUp = true;
          referee.whoServe = 1;
          nPoint++;
          npoAngle = Math.PI*2;
          npoPic = nPoint%10;
          if(npoPic === 0) {
          	nptAngle = Math.PI*2;
            nptPic = nPoint/10;
          }
        }
        else {
      		referee.rHandUp = true;
          referee.whoServe = 2;
          pPoint++;
          ppoAngle = Math.PI*2;
          ppoPic = pPoint%10;
          if(ppoPic === 0) {
          	pptAngle = Math.PI*2;
            pptPic = pPoint/10;
          }
        }
        referee.whoLastHit = 0;
      }
    	//referee.playing = false; //遊戲停止
      //referee.resetPlayerPosition();
      referee.startCount = true;
      player1.state = 8;
      player2.state = 8;
      npcPlayer1.state = 8;
      npcPlayer2.state = 8;
      var tmp = this.v.clone().dot(n);
      var v1 = n.clone().multiplyScalar(tmp);
    	var v2 = this.v.clone().sub(v1);
      v1.multiplyScalar(-0.4);
    	this.v = v1.add(v2);
      this.mesh.position.y = 0.205;
		}
    
  };
  
  this.shoot = function(v) {//傳入vector3，會從現在的ball的mesh的位置發射
		this.v = v;//初速
  };

};

Ball.prototype.collisionDetection = function(p, p0, n){
	var tmp = p.clone().sub(p0).dot(n);
  if (tmp < 0) return false;
  else return true;
}

Ball.prototype.netCollisionDetection = function(){
	var n, p0;
  if(this.mesh.position.x < 0) {
  	p0 = new THREE.Vector3(-0.2, 1.43, -4);
  	n = new THREE.Vector3(-1, 0, 0);
  }
  else {
  	p0 = new THREE.Vector3(0.2, 1.43, -4);
  	n = new THREE.Vector3(1, 0, 0);
  }
  var tmp = this.mesh.position.clone().sub(p0);
  
  if( tmp.y <= 1 && tmp.y >= 0 && tmp.z <= 8 && tmp.z >= 0 ) {
    if(!this.collisionDetection(this.mesh.position, p0, n)) {
    	tmp = this.v.clone().dot(n);
      var v1 = n.clone().multiplyScalar(tmp);
    	var v2 = this.v.clone().sub(v1);
      v1.multiplyScalar(-0.3);
    	this.v = v1.add(v2);
      if(ball.mesh.position.x < 0) this.mesh.position.x = -0.2;
      else if(ball.mesh.position.x > 0) this.mesh.position.x = 0.2;
    }
  }
}

function rotation(vector3, theta, phi) {
  var x = vector3.x * Math.cos(theta) - vector3.y * Math.sin(theta);
  var y = vector3.x * Math.sin(theta) + vector3.y * Math.cos(theta);
  vector3.x = x; 
  vector3.y = y;
  x = vector3.x * Math.cos(phi) + vector3.z * Math.sin(phi);
  var z = vector3.z * Math.cos(phi) - vector3.x * Math.sin(phi);
  vector3.x = x;
  vector3.z = z;
  return vector3;
}

///////////////////////////////////////////////////////////////////////////
var MAXSPEED = 5;
var ARRIVAL_R = 0.5;

var Agent = function (pos, vel) {
	this.pos = pos.clone();
	this.vel = vel.clone();
	this.force = new THREE.Vector3();
	this.target = new THREE.Vector3();
	this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4, 0.2, 32),new THREE.MeshLambertMaterial({
		side: THREE.DoubleSide,
    transparent: true,
		opacity :0.0,
		color: 0x00ffff
	}));
};

Agent.prototype.step = function (dt) 
{
	this.accumForce();
	
	// vel += force*dt
	var tmp = this.force.clone();
	tmp.multiplyScalar (dt);
	this.vel.add (tmp);  

	// velocity modulation by arriving
	var diff = new THREE.Vector3();
  var tmp1 = this.target;
  tmp1.y = 0;
  var tmp2 = this.pos;
  tmp2.y = 0;
	diff.subVectors (tmp1, tmp2);
	var dst = diff.length();
	if (dst < ARRIVAL_R) {
		this.vel.setLength (dst);	
	}
	
	// pos += vel*dt
	tmp.copy (this.vel);
	tmp.multiplyScalar (dt*1.5);
	this.pos.add (tmp); 
};

Agent.prototype.accumForce = function ()
{
	// clear force accumulator
	this.force.set (0,0,0);
	
	var sum = new THREE.Vector3(0,0,0);
	
	// seek
	var tmp = new THREE.Vector3();
	tmp.subVectors (this.target, this.pos);
	tmp.normalize();
	tmp.multiplyScalar (MAXSPEED);
	sum.subVectors (tmp, this.vel);
	
	this.force.copy (sum);
}

///////////////////////////////////////////////////////////////////////////
var robot = function (scene, npc, num){
	
	this.hitBallMachine = new THREE.Object3D();
	THREE.ImageUtils.crossOrigin = '';
	if(npc) {
  	if(num === 1) var bodyColor = THREE.ImageUtils.loadTexture('https://i.imgur.com/pPqkHmM.png');
    else var bodyColor = THREE.ImageUtils.loadTexture('https://i.imgur.com/XdCJXRz.png');
  }
  else {
  	if(num === 1) var bodyColor = THREE.ImageUtils.loadTexture('https://i.imgur.com/oxRKc6I.png');
    else var bodyColor = THREE.ImageUtils.loadTexture('https://i.imgur.com/fDrp2FJ.png');
  }
	var geometry = new THREE.CylinderGeometry(0.24, 0.24, 1.2, 32);
	var material = new THREE.MeshLambertMaterial({map: bodyColor});
	this.body = new THREE.Object3D();
	var mesh = new THREE.Mesh(geometry, material);
	mesh.position.set(0, 0.6, 0);
	this.body.add(mesh);
	this.hitBallMachine.add(this.body);
  
	geometry = new THREE.SphereGeometry(0.25, 32, 32);
  if(npc) material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/tajmEfb.png')});
  else material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/f9dNfsj.jpg')});
	var head = new THREE.Mesh(geometry, material);
	head.position.set(0, 1.4, 0);
	this.body.add(head);
  
  material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/yNp5hMw.jpg')});
	this.hitBallMachineHandLeft = new THREE.Object3D();
	this.body.add(this.hitBallMachineHandLeft);
	this.hitBallMachineHandLeft.rotation.z = 0.25;
	this.hitBallMachineHandLeft.position.y = 1.1;
	this.hitBallMachineHandLeft.rotation.x = Math.PI/2;
	var armLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 32), material);
	armLeft.position.set(-0.33, -0.5, 0);
	this.hitBallMachineHandLeft.add(armLeft);
	
	this.hitBallMachineHandRight = new THREE.Object3D();
	this.body.add(this.hitBallMachineHandRight);
	this.hitBallMachineHandRight.rotation.z = -0.25;
	this.hitBallMachineHandRight.position.y = 1.1;
	this.hitBallMachineHandRight.rotation.x = Math.PI/2;
	var armRight = armLeft.clone();
	armRight.position.set(0.33, -0.5, 0);
	this.hitBallMachineHandRight.add(armRight);
  
	this.handLeft = new THREE.Mesh(new THREE.SphereGeometry(0.1, 32, 32), material);
	this.handLeft.position.set(-0.33, -1, 0);
	this.hitBallMachineHandLeft.add(this.handLeft);
	this.handRight = this.handLeft.clone();
	this.handRight.position.set(0.33, -1, 0);
	this.hitBallMachineHandRight.add(this.handRight);
  	
	var foot = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), material);
	this.hitBallMachine.add(foot);
  
	this.body.rotation.x = -0.2;
	this.hitBallMachineHandLeft.rotation.x = 0.9;
	this.hitBallMachine.rotation.y = Math.PI/2;
	this.hitBallMachine.position.set(0, 0.4, 0);
	scene.add(this.hitBallMachine);
 
};

///////////////////////////////////////////////////////////////////////////
var BUMP = Math.PI/3.49;
var player = function(npc, num) {
		
    this.state = 0; //0:待機  1:發球 2:standBy 3:做球 4:normal攻擊 5:殺球攻擊 //6:移動到殺球地點
    this.npc = npc; //1：電腦, 2：玩家
    this.num = num; //背號
    this.standByPosition = new THREE.Vector3(0, 0, 0);
    this.chaseTarget = new THREE.Vector3(0, 0 ,0);
    this.hitMode = 0;
    //發球用
		this.serveAngleLeft = 0;
		this.serveAngleRight = 0;
		this.startTime = 0;
		this.serveIsOn = false;
		this.serveState = 0;//0,左右手往後 1,右手往前 2,打到球後兩手收回
    this.serveTarget;
    this.isLeft = false;
    //update用
    this.updateAngleLeft = BUMP;
    this.updateAngleRight = BUMP;
    //跳越用
    this.jumpIsOn = false;
	this.jumpServeIsOn = false;
    this.jumpStartTime = 0;
	this.jumpServeState = 0//0:拋球動作，1:拋完球standBy不動，2跳起來，3手準備揮,4手揮出，球射出去了,手正在歸位,5手歸完位，身體正在歸位(著地)
  	this.jumpV = new THREE.Vector3(0, 0, 0);
    this.jumpWaitTime = 0;//等待時間，發球跟殺球共用
    this.jumpState = 0;
    
    //玩家操控的攻擊點
    this.attackTarget = new THREE.Vector3(-4, 0, 0);
    
    this.board = new Agent (new THREE.Vector3 (0, 0, 0), new THREE.Vector3(0,0,0));
    this.robot = new robot (scene, npc, this.num);
    scene.add(this.board.mesh);
    
    this.bump();
 	
  	
 		this.sprite = new SpriteText2D('seek', {
    	align: textAlign.center,
    	font: '20px Courier',
    	fillStyle: '#000000',
    	antialias: true
 	 	});
    this.sprite.scale.set(.02, .02, .02);
  	scene.add(this.sprite);
}

player.prototype.bump = function(){
    if(this.npc) {
    	this.robot.body.rotation.x = 0.2; //Math.PI/15.7
		this.robot.hitBallMachineHandLeft.rotation.x = -0.9; //-Math.PI/3.49
		this.robot.hitBallMachineHandRight.rotation.x = -0.9; //-Math.PI/3.49
        this.board.mesh.position.y = 1.1; //Math.PI/2.85
        this.board.mesh.rotation.z = -0.75; //-Math.PI/4.18; //-0.75
    }
    else {
        this.robot.body.rotation.x = -0.2;
		this.robot.hitBallMachineHandLeft.rotation.x = 0.9;
		this.robot.hitBallMachineHandRight.rotation.x = 0.9;
        this.board.mesh.position.y = 1.1;
        this.board.mesh.rotation.z = 0.75;
    } 
}

player.prototype.set = function(){
    if(this.npc) {
        this.robot.body.rotation.x = 0;
    	this.robot.hitBallMachineHandLeft.rotation.x = -2.1;
    	this.robot.hitBallMachineHandRight.rotation.x = -2.1;
    	this.board.mesh.position.y = 2.05;
    	this.board.mesh.rotation.z = -0.75;
    }
    else {
    	this.robot.body.rotation.x = 0;
    	this.robot.hitBallMachineHandLeft.rotation.x = 2.1;
    	this.robot.hitBallMachineHandRight.rotation.x = 2.1;
    	this.board.mesh.position.y = 2.05;
    	this.board.mesh.rotation.z = 0.75;
    }
}

player.prototype.startServe = function (target) {
		this.serveTarget = target;
		this.startTime = clock.getElapsedTime();
    this.serveIsOn = true;
    this.state = 1;
}

player.prototype.startJump = function(target,jumpV,waitTime){
	this.state = 1;
	this.serveTarget = target;
	this.jumpServeIsOn = true;
	this.jumpIsOn = true;
	this.jumpStartTime = clock.getElapsedTime();
	this.jumpV = jumpV;//初速
	this.jumpWaitTime = waitTime;
}
player.prototype.serve = function(dT){
	this.normalServe();
  this.jumpServe(dT);
}


player.prototype.normalServe = function(){
		if (this.serveIsOn === false) return;
    //console.log(this.state);
		var now = clock.getElapsedTime();
      //console.log(this.serveState)
    if(ball.isOn === false)//球跟著手
  		ball.mesh.position.copy(this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)));//NPC的話其實是左手
		
		if(this.serveState == 0){//如果現在不在Rest中就用BUMP狀態開始用加的
		 	this.serveAngleLeft = BUMP+ (now - this.startTime)*2 ;
		 	this.serveAngleRight = BUMP+ (now - this.startTime)*2*1.5;
		}
    else if(this.serveState == 1){//到Math.PI會迴轉所以從Math.PI開始減
    	this.serveAngleRight = Math.PI*1.3567- (now - this.startTime)*6;
    }
    else{
    	this.serveAngleLeft = Math.PI- (now - this.startTime)*6 ;
    	this.serveAngleRight = Math.PI- (now - this.startTime)*6 ;
    }
    
    
	if (this.serveState == 0 && this.serveAngleLeft > Math.PI){
		this.startTime = clock.getElapsedTime();
		this.serveState = 1;
	}
    if (this.serveState == 1 && this.serveAngleRight < Math.PI &&  ball.isOn === false){
			//ball.isOn=true;
      //ball.shoot(new THREE.Vector3(8, 9, 0));
      //console.log(ball.mesh.position);
      ball.isOn = true;
      this.passTarget(this.serveTarget);
      spikeSound.pause();
			spikeSound.currentTime = 0;
    	spikeSound.play();
      
      this.startTime = clock.getElapsedTime();
      this.serveState=2;
		}
    if(this.serveState == 2 && this.serveAngleLeft < BUMP){
    	this.serveAngleLeft = BUMP;
      this.serveAngleRight = BUMP;
      this.serveState = 0;
      this.serveIsOn = false;
      this.state = 2;///發完球變成stand by
      this.stateTarget = undefined;
    }
    if(this.isLeft === true){
      this.robot.hitBallMachineHandLeft.rotation.x = -1*this.serveAngleRight;//-1反過來，左右手也是
      this.robot.hitBallMachineHandRight.rotation.x = -1*this.serveAngleLeft; 
    } 
    else{
    	this.robot.hitBallMachineHandLeft.rotation.x = this.serveAngleRight;
      this.robot.hitBallMachineHandRight.rotation.x = this.serveAngleLeft;  
    }
}

player.prototype.jumpServe = function(dT){//dT其實是傳給jump用的，發球動作是用jumpStartTime
	if (this.jumpServeIsOn === false) return;
	var now = clock.getElapsedTime();
	//console.log(this.jumpServeState)
    if(ball.isOn === false)//球跟著手
  		ball.mesh.position.copy(this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)));//NPC的話其實是左手
	if(this.jumpServeState == 0){
		this.serveAngleLeft = BUMP+ (now - this.jumpStartTime)*2 ;
		this.serveAngleRight = BUMP+ (now - this.jumpStartTime)*2*1.5;
	}
	if(this.jumpServeState == 3){
		this.serveAngleRight = Math.PI*1.3567- (now - this.jumpStartTime)*6;
	}
  if(this.jumpServeState == 4){
    this.serveAngleLeft = Math.PI- (now - this.jumpStartTime)*6 ;
    this.serveAngleRight = Math.PI- (now - this.jumpStartTime)*6 ;
  }

	if (this.jumpServeState == 0 && this.serveAngleLeft > Math.PI){
		this.jumpStartTime = clock.getElapsedTime();
		this.jumpServeState = 1;
		ball.isOn = true;
		ball.shoot(new THREE.Vector3(0, 5.5, 0));
	}
	if(this.jumpServeState == 1 && (now - this.jumpStartTime) > this.jumpWaitTime){
		this.jumpServeState = 2;
	}
	if(this.jumpServeState >= 2){
		this.jump(dT);
	}
	if(this.jumpServeState == 2){
		var ballY =  ball.mesh.position.y;
		var handY = this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)).y;
		//console.log(Math.abs(ballY-handY));
		if(Math.abs(ballY-handY)<0.85){
		  this.jumpServeState = 3;
		  this.jumpStartTime = clock.getElapsedTime();
		
		}
	}
	if(this.jumpServeState == 3 && this.serveAngleRight < Math.PI){
		this.jumpStartTime = clock.getElapsedTime();
		this.jumpServeState = 4;
		console.log("check");
		ball.isOn = true;
    this.passTarget(this.serveTarget);
    spikeSound.pause();
		spikeSound.currentTime = 0;
    spikeSound.play();
	}
  if(this.jumpServeState == 4 && this.serveAngleLeft < BUMP){
	  this.jumpServeState = 5;
  }
  if(this.jumpServeState == 5 &&  this.jumpIsOn === false){
    this.serveAngleLeft = BUMP;
    this.serveAngleRight = BUMP;
    this.jumpServeState = 0;
    this.jumpServeIsOn = false;
    this.state = 2;///發完球變成stand by
    this.stateTarget = undefined;
  }
    if(this.isLeft === true){
      this.robot.hitBallMachineHandLeft.rotation.x = -1*this.serveAngleRight;//-1反過來，左右手也是
      this.robot.hitBallMachineHandRight.rotation.x = -1*this.serveAngleLeft; 
    } 
    else{
    	this.robot.hitBallMachineHandLeft.rotation.x = this.serveAngleRight;
      this.robot.hitBallMachineHandRight.rotation.x = this.serveAngleLeft;  
    }
}


player.prototype.jump = function(dT){
  if (this.jumpIsOn === false) return;
	//console.log(this.robot.hitBallMachine.position.y);
	/*
  if(this.jumpV.y==5)
	this.recordTime = 0;
  else
	this.recordTime+=dT;
*/
  var f = new THREE.Vector3(0, -9.8, 0);
  var robotPos = new THREE.Vector3(0, 0, 0);
  this.jumpV.add ( f.clone().multiplyScalar(dT) );
  robotPos.copy(this.robot.hitBallMachine.position);
  robotPos.add ( this.jumpV.clone().multiplyScalar(dT) );
  this.robot.hitBallMachine.position.y = robotPos.y;
  if(this.jumpV.y<0){
	  //console.log(ball.mesh.position.y);
  }
  if(this.robot.hitBallMachine.position.y <= 0.39){
    this.robot.hitBallMachine.position.y = 0.4;
  	this.jumpIsOn=false; 
  } 
}

player.prototype.bisection = function(v0,theta,length,ys,ye){//predict bisection
	return (v0*Math.cos(theta)*(-1*v0*Math.sin(theta)+Math.sqrt( v0*Math.sin(theta)*v0*Math.sin(theta) - 2*9.8*(ye-ys) ))-length*9.8);
}

player.prototype.predict = function(end){//傳進預測點end

	var predictTargetPosForSpike = new THREE.Vector3(0, 0, 0);
  predictTargetPosForSpike.copy(end); 
  
  end.y=ball.mesh.position.y;
  var predictTargetPos = new THREE.Vector3(0, 0, 0);
  predictTargetPos.copy(end); //為不改變end值，這邊複製給另外一個
  var length = predictTargetPos.sub(ball.mesh.position).length(); //計算目前位置跟預測點的水平距離

  if(this.state===1 ){
      var v0 = 10; //設定初速，依據不同距離給不同初速
      var temp = length*9.8/(v0*v0); //算出sin-1裡面的部分
      if(temp<1) var theta = 0.5*Math.asin(temp); //如果小於1
      else{//大於一不能放進Math.asin，重新調v0到剛好足夠的數字
        v0 = Math.sqrt(v0*v0*(temp+0.00001));
        var theta = 0.5*Math.asin(length*9.8/(v0*v0));
      }
    }
    else if(this.state===5){
    	
  		var ballCopy  = new THREE.Vector3(0, 0, 0);
  		ballCopy.copy(ball.mesh.position);
      var ye = predictTargetPosForSpike.y;
      //console.log(predictTargetPosForSpike.y);
      ballCopy.y=ye;
      
      length = predictTargetPosForSpike.sub(ballCopy).length();
      
      var ys = ball.mesh.position.y;
      var theta = 0;//-10/180*Math.PI;
      var v0 = 0;
      
      var a = 0;
      var b = 50;
      var e = 0.0001;
      while(1){
      	var m = (a+b)/2;
        var fm = this.bisection(m,theta,length,ys,ye);
        var fa = this.bisection(a,theta,length,ys,ye);
        if(fm*fa<0)
        	b = m;
        else
        	a = m;
      	if((b-a)/2<e){
        	v0 = a;
        	break;
        }
      }
      
    }
    else if(this.state===3){
    	if(length < 2.5){
        var theta = 82.5/180*Math.PI;
        //console.log(theta);
        var v0 = Math.sqrt(length*9.8/Math.sin(2*theta));
      }
      else{
        var theta = 75/180*Math.PI;
        //console.log(theta);
        var v0 = Math.sqrt(length*9.8/Math.sin(2*theta));
      }
      
      //console.log(length);
    }
    else{
      var theta = 50/180*Math.PI;
      //console.log(theta);
      var v0 = Math.sqrt(length*9.8/Math.sin(2*theta));
    }
    
  	//console.log(" theta:"+theta.toFixed(1)/Math.PI*180);
	predictTargetPos.copy(end);
    var ballPos = new THREE.Vector3(0, 0, 0);
    ballPos.copy(ball.mesh.position);
    var temp3 = new THREE.Vector3(1, 0, 0);
    
    if(ball.mesh.position.z<end.z)
    	var phi = -1* temp3.angleTo(predictTargetPos.sub(ballPos));
    else
    	var phi = 1* temp3.angleTo(predictTargetPos.sub(ballPos));
    //ball.isOn=true;
	//ball.shoot(rotation(new THREE.Vector3(v0, 0, 0), theta, phi ));
    
    return [v0, theta, phi];
		//ball.v = rotation(new THREE.Vector3(v0, 0, 0), theta, phi);
}

player.prototype.predictY = function(v0, theta, phi, ye){
  var ys = ball.mesh.position.y;
  var a = 4.9; // 9.8/2
  var b = -v0 * Math.sin(theta);
  var c = ye - ys;
  var t = (b*(-1) + Math.sqrt(Math.pow(b, 2) - 4*a*c)) / (2*a);
  //console.log(t);
  
  var L = v0 * Math.cos(theta) * t;
  var movement = new THREE.Vector3(L, 0, 0);
  var axis = new THREE.Vector3( 0, 1, 0 );
  movement.applyAxisAngle(axis, phi);
  var finalP = new THREE.Vector3( 0, 0, 0 );
  finalP.addVectors(ball.mesh.position.clone(), movement);
  finalP.y = ye;
  /*
	var predictMesh = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({transparent: true, 
						 side:THREE.DoubleSide,color: 0x00ffff}));
	predictMesh.position.copy(finalP);
	scene.add(predictMesh);	
*/
  
  
  
  return [finalP,t];
}

  
player.prototype.update = function(dT){
	if(player1.state === 0 && player2.state === 0 && npcPlayer1.state === 0 && npcPlayer2.state === 0) {
  	if(referee.whoServe === 1) {
    	referee.npcLastMode = 1;
    	referee.whoLastHit = 2;
    	referee.whoServe = 2;
			ball.isOn = false;
  		referee.playing = true;
  		var tmp = Math.random();
      //console.log(tmp);
  		if(tmp > 0.5)
				npcPlayer1.startJump(new THREE.Vector3(4, 2.51, 0),new THREE.Vector3(0, 5, 0),0.1);  
  		else 
				npcPlayer1.startServe(new THREE.Vector3(4, 2.51, 0));
        
      player1.state = 2;
     	player2.state = 2;
     	npcPlayer2.state = 2;
    }
  	return;
  }
	if(this.state === 1){
  	this.serve(dT);
    return;//必要，不然會被下面的調整手臂洗掉機器人的手的位置
  }

	//if(this.state === 0 || this.state === 1) return;
  
  else if(this.state === 2){ //standBy
  	this.board.target.copy(this.standByPosition);
  	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
  	this.board.mesh.position.x = this.board.pos.x;
  	this.board.mesh.position.z = this.board.pos.z;
    if(this.npc) var frontOrBack = -0.8;
    else var frontOrBack = 0.8;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
    
    if(this.hitMode === 0) {
    	if(this.board.mesh.position.y > 1.1)
      	this.board.mesh.position.y -= 0.02;
        
      if(this.updateAngleLeft>BUMP){
    		this.updateAngleLeft -= dT * 3;
    		this.updateAngleRight -= dT * 3;
      }
    }
  }
  
  else if(this.state === 3){ //做球
  	var n = rotation(new THREE.Vector3(0, 1, 0), this.board.mesh.rotation.z, 0); //板子(手)的法線向量
		var p0 = this.board.mesh.localToWorld(new THREE.Vector3(0, -0.1, 0)); 
    // p0為板子(手)上的一點
    var distance = ball.mesh.position.clone().sub(this.board.mesh.localToWorld(new THREE.Vector3(0, 0.3, 0))).lengthSq(); //球與板子(手)的距離
    
  	
    if(distance < 3) { //球跟板子(手)距離小於3，手就開始往上揮
    	this.board.mesh.position.add(n.clone().multiplyScalar(dT*3));
    	this.updateAngleLeft += dT*3;
    	this.updateAngleRight +=  dT*3;
    
    }
    
    if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    //球運動到跟板子(手)同平面
    	var r = ball.mesh.position.clone().sub(p0);
      var r1 = r.clone().sub(n.clone().multiplyScalar(r.clone().dot(n))).lengthSq();
      if (Math.abs(r1) <= 0.16) { //球在板子(手)的範圍內      	
      	if(this.isLeft) {
        	referee.npcLastMode = 3;
        	referee.whoLastHit = 2;
        	//this.passTarget(new THREE.Vector3(2, 0, 0));
          var tmp = this.predict(new THREE.Vector3(-2, 0, 0)); //算出到(x, 0, z)的速度與角度
          var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2]));
          if(!(jumpTarget[1] < 2)) jumpTarget[1] = 1;
          if(this.num === 1) {
          	if(npcPlayer2.state === 6) {
            	npcPlayer2.state = 5; //殺球
      				npcPlayer2.chaseTarget = new THREE.Vector3(-2, 3.7, 0);
	  					npcPlayer2.jumpWaitTime = jumpTarget[1];
	  					npcPlayer2.jumpV = new THREE.Vector3(0, 5, 0);
	  					npcPlayer2.jumpIsOn = true;
            }
          }
          else if(this.num === 2) {
          	if(npcPlayer1.state === 6) {
            	npcPlayer1.state = 5; //殺球
      				npcPlayer1.chaseTarget = new THREE.Vector3(-2, 3.7, 0);
	  					npcPlayer1.jumpWaitTime = jumpTarget[1];
	  					npcPlayer1.jumpV = new THREE.Vector3(0, 5, 0);
	  					npcPlayer1.jumpIsOn = true;
            }
          }
        }
        else {
        	referee.playerLastMode = 3;
        	referee.whoLastHit = 1;
        	//this.passTarget(new THREE.Vector3(-2, 0, 0));
          var tmp = this.predict(new THREE.Vector3(2, 0, 0)); //算出到(x, 0, z)的速度與角度
          var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2]));
					if(!(jumpTarget[1] < 2)) jumpTarget[1] = 1;
          if(this.num === 1) {
          	if(player2.state === 6) {
            	player2.state = 5; //殺球
      				player2.chaseTarget = new THREE.Vector3(2, 3.7, 0);
	  					player2.jumpWaitTime = jumpTarget[1];
	  					player2.jumpV = new THREE.Vector3(0, 5, 0);
	  					player2.jumpIsOn = true;
            }
          }
          else if(this.num === 2) {
          	if(player1.state === 6) {
            	player1.state = 5; //殺球
      				player1.chaseTarget = new THREE.Vector3(2, 3.7, 0);
	  					player1.jumpWaitTime = jumpTarget[1];
	  					player1.jumpV = new THREE.Vector3(0, 5, 0);
	  					player1.jumpIsOn = true;
            }
          }
        }
    		slapSound.pause();
				slapSound.currentTime = 0;
    		slapSound.play();
      }
      this.state = 2;
    }
    
  	//追落點
  	this.board.target.copy(this.chaseTarget);
  	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
  	this.board.mesh.position.x = this.board.pos.x;
  	this.board.mesh.position.z = this.board.pos.z;
    if(this.npc) var frontOrBack = -0.8;
    else var frontOrBack = 0.8;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
  }
  
  else if(this.state === 4){ //normal attack
  	var n = rotation(new THREE.Vector3(0, 1, 0), this.board.mesh.rotation.z, 0); //板子(手)的法線向量
		var p0 = this.board.mesh.localToWorld(new THREE.Vector3(0, -0.1, 0)); 
    // p0為板子(手)上的一點
    var distance = ball.mesh.position.clone().sub(this.board.mesh.localToWorld(new THREE.Vector3(0, 0.3, 0))).lengthSq(); //球與板子(手)的距離
    
    if(distance < 3) { //球跟板子(手)距離小於3，手就開始往上揮
    	this.board.mesh.position.add(n.clone().multiplyScalar(dT*3));
    	this.updateAngleLeft += dT*3;
    	this.updateAngleRight +=  dT*3;
    
    }
    if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    //球運動到跟板子(手)同平面
    	var r = ball.mesh.position.clone().sub(p0);
      var r1 = r.clone().sub(n.clone().multiplyScalar(r.clone().dot(n))).lengthSq();
      if (Math.abs(r1) <= 0.16) { //球在板子(手)的範圍內      	
      	var x = Math.random() * 4.5 + 2.5;
        var z = Math.random() * 6 - 3;
        if(this.isLeft) {
        	referee.npcLastMode = 4;
        	referee.whoLastHit = 2;
          if(x < 3) x++;
          if(x < 3.5) {
          	if(z < 2 && z > -2) z = 2.5;
          }
        	this.passTarget(new THREE.Vector3(x, 0, z));
        }
        else {
        	referee.playerLastMode = 4;
        	referee.whoLastHit = 1;
        	this.passTarget(predictMesh.position.clone());
        }
        this.state = 2;
        
        slapSound.pause();
				slapSound.currentTime = 0;
    		slapSound.play();
      }
      if(!this.isLeft){
      	if(playerCoach.isOne) this.state = 2;
      }
      else if(this.isLeft){
      	if(npcCoach.isOne) this.state = 2;
      }
    }
    
    //追落點
	this.board.target.copy(this.chaseTarget);
	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
	this.board.mesh.position.x = this.board.pos.x;
	this.board.mesh.position.z = this.board.pos.z;
	if(this.npc) var frontOrBack = -0.8;
	else var frontOrBack = 0.8;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
  }
  
  else if(this.state === 5){ //殺球
	
	this.jumpWaitTime -=dT;
	
	if(this.updateAngleRight <= Math.PI && this.jumpState === 0){
    	this.updateAngleLeft += dT*5;
    	this.updateAngleRight +=  dT*5;	
	}
	//if(this.jumpWaitTime<0.1 && this.jumpWaitTime>-0.1 )
		//console.log(this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)));
		
	
	if(this.jumpWaitTime<0 && this.jumpState === 0){
    	var x = Math.random() * 4 + 3;
      var z = Math.random() * 5 - 2.5;
      if(x < 3.5) {
          	if(z < 2 && z > -2) {
            	if(z > 0) z = 2.5;
              else z = -2.5;
          }
      }
		  if(this.isLeft) {
      	referee.npcLastMode = 5;
      	referee.whoLastHit = 2;
        this.passTarget(new THREE.Vector3(x, 0, z));
      }
      else {
      	referee.playerLastMode = 5;
      	x *= -1;
      	referee.whoLastHit = 1;
        this.passTarget(predictMesh.position.clone());
      }
			this.jumpState = 1;
      spikeSound.pause();
			spikeSound.currentTime = 0;
    	spikeSound.play();
	}
	
	if(this.jumpIsOn == false){
		this.state = 2;
		this.jumpState = 0;
	}
	
	if(this.jumpWaitTime<0.7){
		this.jump(dT);
		
    	this.updateAngleLeft -= dT*3;
    	this.updateAngleRight -=  dT*3;	
	}
	else
		console.log("check wait");
	
	//追落點
	this.board.target.copy(this.chaseTarget);
	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
	this.board.mesh.position.x = this.board.pos.x;
	this.board.mesh.position.z = this.board.pos.z;
	if(this.npc) var frontOrBack = -0.8;
	else var frontOrBack = 0.8;	
	
	//this.robot.hitBallMachine.position.x = this.board.mesh.position.x;
	this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;

  }
  else if(this.state === 6){ //移動到殺球位置
  	//追落點
		this.board.target.copy(this.chaseTarget);
		this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
		this.board.mesh.position.x = this.board.pos.x;
		this.board.mesh.position.z = this.board.pos.z;
		if(this.npc) var frontOrBack = -0.8;
		else var frontOrBack = 0.8;	
	
		this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;
  }
  
  else if(this.state === 7){ //回到起始位置
  	//追落點
    if(referee.whoServe === 1) {
    	if(this.isLeft) {
    		if(this.num === 1) this.chaseTarget = new THREE.Vector3(-9, 1.1, 0);
      	else this.chaseTarget = this.standByPosition;
    	}
    	else {
    		if(this.num === 1) this.chaseTarget = this.standByPosition;
      	else this.chaseTarget = this.standByPosition;
    	}
    }
    else {
    	if(this.isLeft) {
    		if(this.num === 1) this.chaseTarget = this.standByPosition;
      	else this.chaseTarget = this.standByPosition;
    	}
    	else {
    		if(this.num === 1) this.chaseTarget = new THREE.Vector3(9, 1.1, 0);
      	else this.chaseTarget = this.standByPosition;
    	}
    }
		this.board.target.copy(this.chaseTarget);
		this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
		this.board.mesh.position.x = this.board.pos.x;
		this.board.mesh.position.z = this.board.pos.z;
		if(this.npc) var frontOrBack = -0.8;
		else var frontOrBack = 0.8;	
	
		this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;
  
  	//回到待機狀態
  	if(this.board.mesh.position.clone().sub(this.chaseTarget).length() < 1) {
    	this.board.vel = new THREE.Vector3(0, 0, 0);
    	this.state = 0;
    }
  }
  else if(this.state === 8){
    return;
  }
  
  
  //實際改robot的數值
  
  if(this.isLeft === true){
    this.robot.hitBallMachineHandLeft.rotation.x = -1*this.updateAngleRight;//-1反過來，左右手也是
    this.robot.hitBallMachineHandRight.rotation.x = -1*this.updateAngleLeft; 
    
  } 
  else{
    this.robot.hitBallMachineHandLeft.rotation.x = this.updateAngleRight;
    this.robot.hitBallMachineHandRight.rotation.x = this.updateAngleLeft;  
  }
  
}


player.prototype.passTarget = function(end){
  var tmp = this.predict(end); //算出到(x, 0, z)的速度與角度
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2])); //將球射出去
  var bumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 1.1); //算出球運動到y=1.1時的位置
  var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  var groundTarget = this.predictY(tmp[0], tmp[1], tmp[2], 0.2);
  //將y=1.1時的位置傳給對場的coach
  if(this.isLeft) {
  	playerCoach.isOn = true;
    playerCoach.groundTarget = groundTarget[0];
  	playerCoach.bumpTarget = bumpTarget[0];
		playerCoach.jumpTarget = jumpTarget[0];
		playerCoach.jumpTime = jumpTarget[1];
	
  }
  else {
   	npcCoach.isOn = true;
    npcCoach.groundTarget = groundTarget[0];
  	npcCoach.bumpTarget = bumpTarget[0];
  	npcCoach.jumpTarget = jumpTarget[0];
		npcCoach.jumpTime = jumpTarget[1];
  }
}

///////////////////////////////////////////////////////////////////////////
var referee = function() {
	//若接發球方贏得一球，除了得一分之外，並取得發球權。而只要發球權交換，獲得發球權球隊球員也必須輪替。
  this.playing = false;
  this.whoServe = 2; //1:player 2:npc
  this.whoLastHit;
  this.lHandUp = false;
  this.rHandUp = false;
  this.playerLastMode = 0;
  this.npcLastMode = 0;
  this.startCount = false;
  this.restartCount = 2;
  
  this.hitBallMachine = new THREE.Object3D();
  THREE.ImageUtils.crossOrigin = '';
	var geometry = new THREE.CylinderGeometry(0.24, 0.24, 1.2, 32);
	var material = new THREE.MeshLambertMaterial({color: 0x008000});
	this.body = new THREE.Object3D();
	var mesh = new THREE.Mesh(geometry, material);
	mesh.position.set(0, 0.6, 0);
	this.body.add(mesh);
	this.hitBallMachine.add(this.body);
  
	geometry = new THREE.SphereGeometry(0.25, 32, 32);
  material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/f9dNfsj.jpg')});
	var head = new THREE.Mesh(geometry, material);
	head.position.set(0, 1.4, 0);
	this.body.add(head);
  
  material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/yNp5hMw.jpg')});
	this.hitBallMachineHandLeft = new THREE.Object3D();
	this.body.add(this.hitBallMachineHandLeft);
	this.hitBallMachineHandLeft.rotation.z = 2.7;
  this.hitBallMachineHandLeft.position.x = -0.3;
	this.hitBallMachineHandLeft.position.y = 1.1;
	var armLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 32), material);
	armLeft.position.set(0, 0.5, 0);
	this.hitBallMachineHandLeft.add(armLeft);
  var cylinder = new THREE.Mesh( new THREE.CylinderGeometry( 0.04, 0.04, 1.2, 32 ), new THREE.MeshBasicMaterial( {color: 0x804000}) );
  cylinder.rotation.z = 1.7;
  cylinder.position.set(0.4, 1.1, 0);
	this.hitBallMachineHandLeft.add( cylinder );

	var plane = new THREE.Mesh( new THREE.PlaneGeometry( 0.4, 0.7, 32 ), new THREE.MeshBasicMaterial( {color: 0xff0000, side: 	THREE.DoubleSide} ) );
	plane.rotation.z = 1.7 + Math.PI/2;
  plane.position.set(0.75, 1.5, 0);
	this.hitBallMachineHandLeft.add( plane );
	
	this.hitBallMachineHandRight = new THREE.Object3D();
	this.body.add(this.hitBallMachineHandRight);
  this.hitBallMachineHandRight.rotation.z = Math.PI - 2.7;
  this.hitBallMachineHandRight.position.x = 0.3;
	this.hitBallMachineHandRight.position.y = 1.1;
	var armRight = armLeft.clone();
	armRight.position.set(0, -0.5, 0);
	this.hitBallMachineHandRight.add(armRight);
  var cylinder2 = new THREE.Mesh( new THREE.CylinderGeometry( 0.04, 0.04, 1.2, 32 ), new THREE.MeshBasicMaterial( {color: 0x804000}) );
  cylinder2.rotation.z = 1.5;
  cylinder2.position.set(0.4, -1.1, 0);
	this.hitBallMachineHandRight.add( cylinder2 );

	var plane2 = new THREE.Mesh( new THREE.PlaneGeometry( 0.4, 0.7, 32 ), new THREE.MeshBasicMaterial( {color: 0xff0000, side: 	THREE.DoubleSide} ) );
	plane2.rotation.z = 1.5 + Math.PI/2;
  plane2.position.set(0.75, -1.5, 0);
	this.hitBallMachineHandRight.add( plane2 );
  
	var handLeft = new THREE.Mesh(new THREE.SphereGeometry(0.1, 32, 32), material);
	handLeft.position.set(0, 1, 0);
	this.hitBallMachineHandLeft.add(handLeft);
	handRight = handLeft.clone();
	handRight.position.set(0, -1, 0);
	this.hitBallMachineHandRight.add(handRight);
  	
	var foot = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), material);
	this.hitBallMachine.add(foot);
  
	this.hitBallMachine.rotation.y = -0.6;
	this.hitBallMachine.position.set(0, 0.4, 5.5);
	scene.add(this.hitBallMachine);
}

referee.prototype.update = function() {
	if(!this.playing) { //遊戲停止，所有player待機
  	npcPlayer1.state = 0;
    npcPlayer2.state = 0;
    player1.state = 0;
    player2.state = 0;
  }
  this.leftHandUp();
	this.rightHandUp();
  this.leftHandDown();
  this.rightHandDown();

}

referee.prototype.resetPlayerPosition = function() {
	npcPlayer1.state = 0;
  npcPlayer2.state = 0;
  player1.state = 0;
  player2.state = 0;
  
  if(spike) {
  	spike = !spike;
    $("#spike").toggleClass("btn-active");
  }
  if(!pass) {
  	pass = !pass;
    $("#pass").toggleClass("btn-active");
  }
	if(referee.whoServe === 1) {
  	npcPlayer1.board.mesh.position.set(-9, 1.1, 0);
 npcPlayer1.robot.hitBallMachine.position.set(npcPlayer1.board.mesh.position.x-0.8, 0.4, npcPlayer1.board.mesh.position.z);
 	npcPlayer1.bump();
  	npcPlayer2.board.mesh.position.set(-4, 1.1, 1.8);
 npcPlayer2.robot.hitBallMachine.position.set(npcPlayer2.board.mesh.position.x-0.8, 0.4, npcPlayer2.board.mesh.position.z);
 		npcPlayer2.bump();
  	player1.board.mesh.position.set(4, 1.1, -1.8);
 player1.robot.hitBallMachine.position.set(player1.board.mesh.position.x+0.8, 0.4, player1.board.mesh.position.z);
 		player1.bump();
  	player2.board.mesh.position.set(3, 1.1, 1.8);
 player2.robot.hitBallMachine.position.set(player2.board.mesh.position.x+0.8, 0.4, player2.board.mesh.position.z);
 		player2.bump();
  }
  else {
  	npcPlayer1.board.mesh.position.set(-3, 1.1, -1.8);
 npcPlayer1.robot.hitBallMachine.position.set(npcPlayer1.board.mesh.position.x-0.8, 0.4, npcPlayer1.board.mesh.position.z);
 	npcPlayer1.bump();
    npcPlayer2.board.mesh.position.set(-4, 1.1, 1.8);
 npcPlayer2.robot.hitBallMachine.position.set(npcPlayer2.board.mesh.position.x-0.8, 0.4, npcPlayer2.board.mesh.position.z);
 		npcPlayer2.bump();
    player1.board.mesh.position.set(9, 1.1, 0);
 player1.robot.hitBallMachine.position.set(player1.board.mesh.position.x+0.8, 0.4, player1.board.mesh.position.z);
 		player1.bump();
  	player2.board.mesh.position.set(3, 1.1, 1.8);
 player2.robot.hitBallMachine.position.set(player2.board.mesh.position.x+0.8, 0.4, player2.board.mesh.position.z);
 		player2.bump();
  }
  
  
}

referee.prototype.leftHandUp = function() {
	if(this.lHandUp) {
  	if(this.hitBallMachineHandLeft.rotation.z > 1.4)
    	this.hitBallMachineHandLeft.rotation.z -= 0.03;
		else this.lHandUp = false;
  }
}
referee.prototype.leftHandDown = function() {
	if(!this.lHandUp) {
		if(this.hitBallMachineHandLeft.rotation.z < 2.7)
    	this.hitBallMachineHandLeft.rotation.z += 0.03;
  }
}
referee.prototype.rightHandUp = function() {
	if(this.rHandUp) {
  	if(this.hitBallMachineHandRight.rotation.z < Math.PI - 1.4)
    	this.hitBallMachineHandRight.rotation.z += 0.03;
    else this.rHandUp = false;
  }
}
referee.prototype.rightHandDown = function() {
	if(!this.rHandUp) {
		if(this.hitBallMachineHandRight.rotation.z > Math.PI - 2.7)
  		this.hitBallMachineHandRight.rotation.z -= 0.03;
  }
}
///////////////////////////////////////////////////////////////////////////
var coach = function(npc) {
  this.isOn = false;
  this.npc = npc;
  this.bumpTarget = new THREE.Vector3(0, 0, 0);
  this.jumpTarget = new THREE.Vector3(0, 0, 0);
  this.groundTarget = new THREE.Vector3(0, 0, 0);
  this.jumpTime = 0;
  this.isOne;
}

coach.prototype.update = function() {
	if (this.isOn === false) return;
  this.isOn = false;
  
  if(this.npc) {
  	npcPlayer1.board.vel = new THREE.Vector3(0, 0, 0);
    npcPlayer2.board.vel = new THREE.Vector3(0, 0, 0);
    
  	if(this.groundTarget.x < -8 || this.groundTarget.z < -4 || this.groundTarget.z > 4) {
    	npcPlayer1.state = 2;
    	npcPlayer2.state = 2;
      return;
    }
    
  	var dis1 = this.bumpTarget.clone().sub(npcPlayer1.board.mesh.position.clone()).lengthSq();
    var dis2 = this.bumpTarget.clone().sub(npcPlayer2.board.mesh.position.clone()).lengthSq();
	  //這邊要一個if來判斷攻擊方式?
///////////////////////////////////////////////////////////// 
		if(dis1 >= dis2) {
      if(referee.playerLastMode === 5) {
      	this.isOne = false;
    		npcPlayer2.state = 3; //做球
      	npcPlayer2.chaseTarget = this.bumpTarget;
      }
      else if(referee.playerLastMode != 5 && this.bumpTarget.x > -4) {
				this.isOne = true;
      	npcPlayer2.state = 4; //攻擊
      	npcPlayer2.chaseTarget = this.bumpTarget;
      }
      else {
      	var needToSpike = true;
      	this.isOne = false;
    		npcPlayer2.state = 3; //做球
      	npcPlayer2.chaseTarget = this.bumpTarget;
      }
      
			tmp = Math.random() - 0.5;
      if(npcPlayer2.state === 4) {
      	npcPlayer1.state = 2;
      }
      else if(needToSpike) {
      	npcPlayer1.state = 6; //殺球
        npcPlayer1.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
        needToSpike = false;
      }
      else if(tmp > 0 && npcPlayer2.state != 4) {
      	npcPlayer1.state = 6; //殺球
        npcPlayer1.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
      }
      else if(tmp < 0 && npcPlayer2.state != 4) {
      	npcPlayer1.state = 4; //攻擊
      	npcPlayer1.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
      }
    }
    else {
    	if(referee.playerLastMode === 5) {
      	this.isOne = false;
    		npcPlayer1.state = 3; //做球
      	npcPlayer1.chaseTarget = this.bumpTarget;
      }
      else if(referee.playerLastMode != 5 && this.bumpTarget.x > -4) {
				this.isOne = true;
      	npcPlayer1.state = 4; //攻擊
      	npcPlayer1.chaseTarget = this.bumpTarget;
      }
      else{
      	var needToSpike = true;
      	this.isOne = false;
    		npcPlayer1.state = 3; //做球
      	npcPlayer1.chaseTarget = this.bumpTarget;
      }

      tmp = Math.random() - 0.5;
      if(npcPlayer1.state === 4) {
      	npcPlayer2.state = 2;
      }
      else if(needToSpike) {
      	npcPlayer2.state = 6; //殺球
        npcPlayer2.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
        needToSpike = false;
      }
      else if(tmp > 0 && npcPlayer1.state != 4) {
      	npcPlayer2.state = 6; //殺球
        npcPlayer2.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
      }
      else if (tmp < 0 && npcPlayer1.state != 4){
      	npcPlayer2.state = 4; //攻擊
      	npcPlayer2.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
      }
    }
    
/////////////////////////////////////////////////////////////

  }
  else {
  	player1.board.vel = new THREE.Vector3(0, 0, 0);
    player2.board.vel = new THREE.Vector3(0, 0, 0);
    
  	if(this.groundTarget.x > 8 || this.groundTarget.z < -4 || this.groundTarget.z > 4) {
    	player1.state = 2;
    	player2.state = 2;
      return;
    }
    
  	var dis1 = this.bumpTarget.clone().sub(player1.board.mesh.position.clone()).lengthSq();
    var dis2 = this.bumpTarget.clone().sub(player2.board.mesh.position.clone()).lengthSq();
    
    if(dis1 >= dis2) {
    	if(pass) {
      	this.isOne = false;
    		player2.state = 3; //做球
      	player2.chaseTarget = this.bumpTarget;
        if(spike) {
        	player1.state = 6; //殺球
        }
        else player1.state = 4; //攻擊
      	player1.chaseTarget = new THREE.Vector3(2, 1.1, 0);
      }
      else {
      	this.isOne = true;
      	if(spike) {
        	player2.state = 5; //殺球
      		player2.chaseTarget = this.jumpTarget;
	  			player2.jumpWaitTime = this.jumpTime;
	  			player2.jumpV = new THREE.Vector3(0, 5, 0);
	  			player2.jumpIsOn = true;
        }
        else {
        	player2.state = 4; //攻擊
      		player2.chaseTarget = this.bumpTarget;
        }
        player1.state = 2; //stand by
      }
    }
    else {
    	if(pass) {
      	this.isOne = false;
    		player1.state = 3; //做球
      	player1.chaseTarget = this.bumpTarget;
        if(spike) {
        	player2.state = 6; //殺球
        }
        else player2.state = 4; //攻擊
        player2.chaseTarget = new THREE.Vector3(2, 1.1, 0);
      }
      else {
      	this.isOne = true;
      	if(spike) {
        	player1.state = 5; //殺球
      		player1.chaseTarget = this.jumpTarget;
	  			player1.jumpWaitTime = this.jumpTime;
	  			player1.jumpV = new THREE.Vector3(0, 5, 0);
	  			player1.jumpIsOn = true;
        }
        else {
        	player1.state = 4; //攻擊
      		player1.chaseTarget = this.bumpTarget;
        }
        player2.state = 2; //stand by
      }
    }
  }
}


var scene = new THREE.Scene();
var renderer, camera, controls;
var basicScene = new BasicScene (scene);
var ball = new Ball (scene);
var clock = new THREE.Clock();
var referee = new referee();
var keyboard = new KeyboardState();
var attackPosRange = 1; //0:left 1:mid 2:right
var attackRangeLine, pass = true, spike = false;
var SpriteText2D = THREE_Text.SpriteText2D;
var textAlign = THREE_Text.textAlign;
var slapSound, spikeSound;
var raycaster;
var mouse = new THREE.Vector2();
var pickables = [];
var predictMesh;
var buttonLight = 0, countLight = 0;
var nPoint = 0, pPoint = 0;
var npcPointTen, npcPointOne, playerPointTen, playerPointOne;
var playerPoint1, playerPoint2, npcPoint1, npcPoint2;
var nptAngle = 0, npoAngle = 0, pptAngle = 0, ppoAngle = 0;
var nptPic = 10, npoPic = 10, pptPic = 10, ppoPic = 10;

$("#pass").click(function() {
	pass = !pass;
  $("#pass").toggleClass("btn-active");
});

$("#spike").click(function() {
	spike = !spike;
  $("#spike").toggleClass("btn-active");
});
$('#start').click(function() {
	referee.whoLastHit = 1;
	if(player1.state === 0) {
		referee.whoServe = 1;
		ball.isOn = false;
  	referee.playing = true;
  
  	var tmp  = predictMesh.position.clone();
  	if(spike) {
    	tmp.x += 1.7;
      var tmp2 = predictMesh.position.x / 10;
      var tmpZ = predictMesh.position.z / 10;
      tmp.x -= tmp2;
      tmp.z -= tmpZ; 
			player1.startJump(tmp,new THREE.Vector3(0, 5, 0),0.1);  
    }
  	else {
    	tmp.x += 0.6;
      var tmp2 = predictMesh.position.x / 8;
      var tmpZ = predictMesh.position.z / 10;
      tmp.x -= tmp2;
      tmp.z -= tmpZ; 
			player1.startServe(tmp);
    }
      
     player2.state = 2;
     npcPlayer1.state = 2;
     npcPlayer2.state = 2;
  }
});

init();
animate();

function init() {
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(16.5, 7, 0);
  //camera.position.set(0, 6, 15);
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  
  //點擊落點
  attackCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  attackCamera.position.set(30, 0, 0);
  attackControls = new THREE.OrbitControls(attackCamera, renderer.domElement);
  cameraHUD = new THREE.OrthographicCamera(-10, 10, 10, -10, -1, 1000);
  cameraHUD.position.z = 0;
  
  renderer.autoClear = false;
  sceneHUD = new THREE.Scene();
  
  //不同view的HUD
var fframe = new THREE.Mesh(new THREE.PlaneGeometry(5.1, 0.08), new THREE.MeshBasicMaterial({
    color: 0xff0000,
    depthTest: false
  }));
var fframe2 = new THREE.Mesh(new THREE.PlaneGeometry(6.3, 0.08), new THREE.MeshBasicMaterial({
    color: 0xff0000,
    opacity: 0.6,
    transparent: true,
    depthTest: false
  }));
  var fup = fframe.clone();
  fup.position.set (7.3,-3.4,0);
  var fdown = fframe.clone();
  fdown.position.set (7.3,-9.68,0);
  var fleft = fframe2.clone();
  fleft.rotation.z = Math.PI/2;
  fleft.position.set (4.77,-6.6,0);
  var fright = fframe2.clone();
  fright.rotation.z = Math.PI/2;
  fright.position.set (9.83,-6.6,0);
  sceneHUD.add(fup);
  sceneHUD.add(fdown);
  sceneHUD.add(fleft);
  sceneHUD.add(fright);
  
  npcCoach = new coach(1);
  playerCoach = new coach(0);
  
  npcPlayer1 = new player(1, 1);  
  npcPlayer1.board.mesh.position.set(-3, 1.1, -1.8);
 npcPlayer1.robot.hitBallMachine.position.set(npcPlayer1.board.mesh.position.x-0.8, 0.4, npcPlayer1.board.mesh.position.z);
  npcPlayer1.standByPosition = new THREE.Vector3(-3, 1.1, -1.8);
  npcPlayer1.isLeft = true;
  
  npcPlayer2 = new player(1, 2);  
  npcPlayer2.board.mesh.position.set(-4, 1.1, 1.8);
 npcPlayer2.robot.hitBallMachine.position.set(npcPlayer2.board.mesh.position.x-0.8, 0.4, npcPlayer2.board.mesh.position.z);
  npcPlayer2.standByPosition = new THREE.Vector3(-4, 1.1, 1.8);
  npcPlayer2.isLeft = true;
  
  player1 = new player(0, 1);  
  player1.board.mesh.position.set(9, 1.1, 0);
 player1.robot.hitBallMachine.position.set(player1.board.mesh.position.x+0.8, 0.4, player1.board.mesh.position.z);
 player1.standByPosition = new THREE.Vector3(4, 1.1, -1.8);

 	player2 = new player(0, 2);  
  player2.board.mesh.position.set(3, 1.1, 1.8);
 player2.robot.hitBallMachine.position.set(player2.board.mesh.position.x+0.8, 0.4, player2.board.mesh.position.z);
 	player2.standByPosition = new THREE.Vector3(3, 1.1, 1.8);
  
  	predictMesh = new THREE.Mesh(new THREE.CylinderGeometry( 0.05, 0.35, 0.6, 5 ), new THREE.MeshLambertMaterial({color: 0xff0000, transparent: true, 
                         side:THREE.DoubleSide}));
  predictMesh.rotation.x = Math.PI;    
  predictMesh.position.set(-4, 1.1, 1);
 	scene.add(predictMesh);	
  
  //記分板
  	var scoreBoard = new THREE.Object3D();
    scoreBoard.position.set(0, 0, -6.5);
    scoreBoard.rotation.y = 1.3;
    scene.add(scoreBoard);
    var geometry = new THREE.CylinderGeometry( 0.1, 0.1, 2, 32 );
		var material = new THREE.MeshLambertMaterial( {color: 0x285fdd} );
		var bottom = new THREE.Mesh( geometry, material );
  	bottom.rotation.z = Math.PI/2;
  	bottom.position.set(0, 0.3, -0.5);
		scoreBoard.add( bottom ); 
    var bottom2 = bottom.clone();
    bottom2.position.set(0, 0.3, 0.5);
    scoreBoard.add( bottom2 ); 
    var bottom3 = new THREE.Mesh( new THREE.CylinderGeometry( 0.15, 0.15, 0.3, 32 ), new THREE.MeshLambertMaterial( {color: 0x000000} ) );
    bottom3.position.set(1, 0.3, 0.5);
    bottom3.rotation.z = Math.PI/2;
    scoreBoard.add( bottom3 ); 
    var bottom4 = bottom3.clone();
    bottom4.position.set(1, 0.3, -0.5);
    scoreBoard.add( bottom4 ); 
    var bottom5 = bottom3.clone();
    bottom5.position.set(-1, 0.3, 0.5);
    scoreBoard.add( bottom5 ); 
    var bottom6 = bottom3.clone();
    bottom6.position.set(-1, 0.3, -0.5);
    scoreBoard.add( bottom6 ); 
    var middle = new THREE.Mesh( new THREE.CylinderGeometry( 0.07, 0.07, 1.2, 32 ), new THREE.MeshLambertMaterial( {color: 0x804000} ) );
    middle.position.set(0, 0.8, 0.3);
    middle.rotation.x = -0.45;
    scoreBoard.add( middle ); 
    var middle2 = middle.clone();
    middle2.position.set(0, 0.8, -0.3);
    middle2.rotation.x = 0.45;
    scoreBoard.add( middle2 ); 
    var middle3 = new THREE.Mesh( new THREE.CylinderGeometry( 0.08, 0.08, 1.8, 32 ), new THREE.MeshLambertMaterial( {color: 0x927e39} ) );
    middle3.position.set(0, 2.2, 0);
    scoreBoard.add( middle3 ); 
    var top = new THREE.Mesh( new THREE.CylinderGeometry( 0.08, 0.08, 2.8, 32 ), new THREE.MeshLambertMaterial( {color: 0xc9bb40} ) );
    top.position.set(0, 3.1, 0);
    top.rotation.z = Math.PI/2;
    scoreBoard.add( top ); 
    var npcBoard = new THREE.Mesh( new THREE.PlaneGeometry( 1.3, 0.5, 32 ), new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/eMkFej9.png'),  side:THREE.DoubleSide}) );
    npcBoard.position.set(-0.7, 1.7, 0);
    scoreBoard.add(npcBoard ); 
    var youBoard = new THREE.Mesh( new THREE.PlaneGeometry( 1.3, 0.5, 32 ), new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/wGSYvnr.png'),  side:THREE.DoubleSide}) );
    youBoard.position.set(0.7, 1.7, 0);
    scoreBoard.add(youBoard ); 
    
    npcPointTen = new THREE.Object3D();
    npcPointTen.position.set(-1.05, 3.1, 0);
    THREE.ImageUtils.crossOrigin = '';
		var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/wymDw47.png'),  side:THREE.DoubleSide});
    npcPoint1 = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), material );
    npcPointTen.add(npcPoint1);
    npcPoint1.position.set(0, -0.55, 0);
    scoreBoard.add(npcPointTen);
    
    npcPointOne = new THREE.Object3D();
    npcPointOne.position.set(-0.4, 3.1, 0);
    npcPoint2 = npcPoint1.clone();
    npcPointOne.add(npcPoint2);
    npcPoint2.position.set(0, -0.55, 0);
    scoreBoard.add(npcPointOne);
    
    playerPointTen = new THREE.Object3D();
    playerPointTen.position.set(0.4, 3.1, 0);
    material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/8kte6xE.png'),  side:THREE.DoubleSide});
    playerPoint1 = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), material );
    playerPointTen.add(playerPoint1);
    playerPoint1.position.set(0, -0.55, 0);
    scoreBoard.add(playerPointTen);
    
    playerPointOne = new THREE.Object3D();
    playerPointOne.position.set(1.05, 3.1, 0);
    playerPoint2 = playerPoint1.clone();
    playerPointOne.add(playerPoint2);
    playerPoint2.position.set(0, -0.55, 0);
    scoreBoard.add(playerPointOne);
  
  slapSound = document.getElementById ('slapSound');
  slapSound.volume = 1.0;
  spikeSound = document.getElementById ('spikeSound');
  spikeSound.volume = 1.0;
  
  pickables.push(basicScene.floor);
  raycaster = new THREE.Raycaster();
  document.addEventListener('mousedown', onDocumentMouseDown, false);
  
  window.addEventListener('resize', onWindowResize, false);
}

function onDocumentMouseDown(event) {

  event.preventDefault();
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

	if(mouse.x >= 0.65 && mouse.x <= 0.837 && mouse.y <= -0.429 && mouse.y >= -0.888 ) {
  	var x = (mouse.x-0.65) / (0.837 - 0.65);
    x = 3 - x * 6;
    var y = (mouse.y+0.888) / (0.888 - 0.429);
    y = -0.8 - y * 6;
    predictMesh.position.set(y, 1.1, x);
  }
}

function rotationPoint(obj3D, plane, angle, pic, who) {
	if(angle > 0) {
  	if(angle <= Math.PI * 3 / 4) {
    	if(pic != 10) {
    		THREE.ImageUtils.crossOrigin = '';
        if(pic === 0) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/wymDw47.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/8kte6xE.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 1) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/HMgzB7H.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/8AusPQF.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 2) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/g5ENXGp.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/YIotKIY.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 3) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/MClxbG0.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/AA78hBK.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 4) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/x0Fkovx.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/CeBJEGv.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 5) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/llXH3eP.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/e8UbrHv.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 6) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/DcpKWp4.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/8qU0ODi.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 7) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/upFCUSk.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/voGh3Ll.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 8) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/eZElsTg.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/bkRwsBy.png'),  side:THREE.DoubleSide});
          }
        }
        else if(pic === 9) {
        	if(who === 1 || who === 2) {
						var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/y2rLsGB.png'),  side:THREE.DoubleSide});
					}
          else {
          	var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/OAUHYyq.png'),  side:THREE.DoubleSide});
          }
        }
    		plane = new THREE.Mesh( new THREE.PlaneGeometry( 0.6, 0.9, 32 ), material );
    		obj3D.add(plane);
    		plane.position.set(0, -0.55, 0);
        pic = 10;
      }
    }
    obj3D.rotation.y -= 0.1;
    if(who === 1) {
    	nptAngle -= 0.1;
      if(nptAngle <= 0) nptAngle = 0;
    }
    else if(who === 2) {
    	npoAngle -= 0.1;
      if(npoAngle <= 0) npoAngle = 0;
    }
    else if(who === 3) {
    	pptAngle -= 0.1;
      if(pptAngle <= 0) pptAngle = 0;
    }
    else {
    	ppoAngle -= 0.1;
      if(ppoAngle <= 0) ppoAngle = 0;
    }
  }
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  attackCamera.aspect = window.innerWidth / window.innerHeight;
  attackCamera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	attackCamera.lookAt(new THREE.Vector3(-3.6, 0, 0));
	attackCamera.position.set(-3.5, 10, 0);
//npcPlayer1.robot.hitBallMachineHandLeft.rotation.x = -Math.PI*1.07
	renderer.clear(true);
  controls.update();
  attackControls.update();
  keyboard.update();
  
  //npcPointTen.rotation.x -= 0.03;
  
  var dT = clock.getDelta();
  referee.update();
  ball.update(dT);
  npcCoach.update();
  playerCoach.update();
  npcPlayer1.update(dT);
  npcPlayer2.update(dT);
  player1.update(dT);
  player2.update(dT);
  
  //test jump用，之後放進去update?
  npcPlayer1.jumpServe(dT);
  
  predictMesh.rotation.y += 0.03;
  
  //point
  rotationPoint(npcPointTen, npcPoint1, nptAngle, nptPic, 1);
  rotationPoint(npcPointOne, npcPoint2, npoAngle, npoPic, 2);
  rotationPoint(playerPointTen, playerPoint1, pptAngle, pptPic, 3);
  rotationPoint(playerPointOne, playerPoint2, ppoAngle, ppoPic, 4);
  
  if(referee.whoServe === 2) {
  	var tmp = buttonLight - clock.getElapsedTime();
  	if(player1.state === 0 && tmp < 0) {
  		$("#start").toggleClass("btn-active");
      buttonLight = clock.getElapsedTime() + 0.5;
      countLight ++;
    }
  }
  else {
  	if(countLight % 2 === 1) {
    	$("#start").toggleClass("btn-active");
      countLight = 0;
    }
  }
  
  if(referee.startCount) {
  	referee.restartCount -= dT;
    if(referee.restartCount <= 0) {
    	 referee.restartCount = 2;
        referee.startCount = false;
        ball.isOn = false;
        referee.resetPlayerPosition();
    }
  }
  
  //攻擊點操作
    if (keyboard.pressed("up")) {
  	if (predictMesh.position.x > -7.3) predictMesh.position.x -= 0.1; 
  } if (keyboard.pressed("down")) {
  	if (predictMesh.position.x < -1) predictMesh.position.x += 0.1; 
  } if (keyboard.pressed("left")) {
		if (predictMesh.position.z < 3.5) predictMesh.position.z += 0.1; 
  } if (keyboard.pressed("right")) {
		if (predictMesh.position.z > -3.5) predictMesh.position.z -= 0.1;
  } 
  
  //狀態顯示
  if(npcPlayer1.state === 0) npcPlayer1.sprite.text = "ready";
  else if(npcPlayer1.state === 1) npcPlayer1.sprite.text = "serve";
  else if(npcPlayer1.state === 2) npcPlayer1.sprite.text = "stand by";
  else if(npcPlayer1.state === 3) npcPlayer1.sprite.text = "pass";
  else if(npcPlayer1.state === 4) npcPlayer1.sprite.text = "bump";
  else if(npcPlayer1.state === 5) npcPlayer1.sprite.text = "spike";
  else if(npcPlayer1.state === 6) npcPlayer1.sprite.text = "spike";
  else if(npcPlayer1.state === 8) npcPlayer1.sprite.text = "waiting";
  
  if(npcPlayer2.state === 0) npcPlayer2.sprite.text = "ready";
  else if(npcPlayer2.state === 1) npcPlayer2.sprite.text = "serve";
  else if(npcPlayer2.state === 2) npcPlayer2.sprite.text = "stand by";
  else if(npcPlayer2.state === 3) npcPlayer2.sprite.text = "pass";
  else if(npcPlayer2.state === 4) npcPlayer2.sprite.text = "bump";
  else if(npcPlayer2.state === 5) npcPlayer2.sprite.text = "spike";
  else if(npcPlayer2.state === 6) npcPlayer2.sprite.text = "spike";
  else if(npcPlayer2.state === 8) npcPlayer2.sprite.text = "waiting";
  
  if(player1.state === 0) player1.sprite.text = "ready";
  else if(player1.state === 1) player1.sprite.text = "serve";
  else if(player1.state === 2) player1.sprite.text = "stand by";
  else if(player1.state === 3) player1.sprite.text = "pass";
  else if(player1.state === 4) player1.sprite.text = "bump";
  else if(player1.state === 5) player1.sprite.text = "spike";
  else if(player1.state === 6) player1.sprite.text = "spike";
  else if(player1.state === 8) player1.sprite.text = "waiting";
  
  if(player2.state === 0) player2.sprite.text = "ready";
  else if(player2.state === 1) player2.sprite.text = "serve";
  else if(player2.state === 2) player2.sprite.text = "stand by";
  else if(player2.state === 3) player2.sprite.text = "pass";
  else if(player2.state === 4) player2.sprite.text = "bump";
  else if(player2.state === 5) player2.sprite.text = "spike";
  else if(player2.state === 6) player2.sprite.text = "spike";
  else if(player2.state === 8) player2.sprite.text = "waiting";
  
  player1.sprite.position.copy(player1.robot.hitBallMachine.position);
  player1.sprite.position.x -= 0.5;
  player1.sprite.position.y += 2;
  player2.sprite.position.copy(player2.robot.hitBallMachine.position);
  player2.sprite.position.x -= 0.5;
  player2.sprite.position.y += 2;
  npcPlayer1.sprite.position.copy(npcPlayer1.robot.hitBallMachine.position);
  npcPlayer1.sprite.position.x += 0.5;
  npcPlayer1.sprite.position.y += 2;
  npcPlayer2.sprite.position.copy(npcPlayer2.robot.hitBallMachine.position);
  npcPlayer2.sprite.position.x += 0.5;
  npcPlayer2.sprite.position.y += 2;

  //player1.serve();
  //npcPlayer1.serve();
  //console.log(npcPlayer1.state);
  attackCamera.lookAt(new THREE.Vector3(-3.6, 0, 0));
	attackCamera.position.set(-3.5, 10, 0);
  requestAnimationFrame(animate);
  render();
}

function render() {
  var WW = window.innerWidth;
  var HH = window.innerHeight;
	renderer.setScissorTest(true);

	renderer.setViewport(0, 0, WW, HH);
  renderer.setScissor(0, 0, WW, HH);
  renderer.clear();
  renderer.render(scene, camera);
  
  renderer.render(sceneHUD, cameraHUD);
  renderer.setViewport(WW/1.35, HH/60, WW/4, HH/3.2);
  renderer.setScissor(WW/1.35, HH/60, WW/4, HH/3.2);
  renderer.clear();
  attackCamera.aspect = window.innerWidth / window.innerHeight;
  attackCamera.updateProjectionMatrix();
  renderer.render(scene, attackCamera);
  
  renderer.setScissorTest(false);
}

// important to add this 
// in jsfiddle!
window.focus();
</script>
</body>

</html>