<html><head>
<style>
#info {
  position: absolute;
  top: 2%;
  width: 100%;
  padding: 10px;
  text-align: center;
  color: #ffff00
}

body {
  overflow: hidden;
}

#left {
  position: absolute;
  border-radius: 1000px;
  left : 81%;
  top: 77%;
}
#right {
  position: absolute;
  border-radius: 1000px;
  left : 89%;
  top: 77%;
}

#pass {
  position: absolute;
  border-radius: 1000px;
  left : 6%;
  top: 77%;
}

#spike {
  position: absolute;
  border-radius: 1000px;
  left : 13%;
  top: 77%;
}

#start {
  position: absolute;
  border-radius: 1000px;
  left : 20%;
  top: 77%;
}

</style>
</head>

<body> 
<div id="info"></div>
<button id="left"><img src="https://i.imgur.com/u2ZDBjb.png"></button>
<button id="right"><img src="https://i.imgur.com/q8ufUNH.png"></button>
<button id="pass" style="background-color:#999999"><img src="http://i.imgur.com/ggNWvGw.png"></button>
<button id="spike"><img src="http://i.imgur.com/YDRuFKe.png"></button>
<button id="start"><img src="http://i.imgur.com/CxnwlRY.png"></button>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r76/three.min.js"></script>
<script src="https://dl.dropboxusercontent.com/u/3587259/Code/Threejs/OrbitControls.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>
<script src="https://rawgit.com/jyunming-chen/tutsplus/master/js/text2D.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<audio id="soundtrack" autoplay loop style="display:none">
<source src="https://youtingkuo.github.io/sound/AlohaBreeze.mp3" type='audio/mp3'>
</audio>
<audio id="slapSound" style="display:none">
<source src="https://youtingkuo.github.io/sound/slap.mp3" type='audio/mp3'>
</audio>
<audio id="spikeSound" style="display:none">
<source src="https://youtingkuo.github.io/sound/spike.mp3" type='audio/mp3'>
</audio>

<script>
var BasicScene = function (scene){
    var light1 = new THREE.PointLight();
    light1.position.set(0, 10, -30);
    scene.add(light1);
    var light2 = new THREE.PointLight();
    light2.position.set(0, 10, 30);
    scene.add(light2);
    var light3 = new THREE.PointLight();
    light3.position.set(-30, 10, 0);
    scene.add(light3);
    var light4 = new THREE.PointLight();
    light4.position.set(30, 10, 0);
    scene.add(light4);

    THREE.ImageUtils.crossOrigin = '';
    var geometry = new THREE.CylinderGeometry( 50, 50, 50, 32, 32 );
		var material = new THREE.MeshBasicMaterial ({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/fJxaqVc.jpg'),  side:THREE.DoubleSide});
		var cylinder = new THREE.Mesh( geometry, material );
    cylinder.position.y = 12.5;
		scene.add( cylinder );
	
  	var texture = THREE.ImageUtils.loadTexture('https://i.imgur.com/uLAXfWL.jpg');
  
	this.floor = new THREE.Mesh(new THREE.PlaneBufferGeometry(32,16,32), new THREE.MeshBasicMaterial({map: texture, 
                         transparent: true, 
                         side:THREE.DoubleSide}));
	this.floor.rotation.x=-Math.PI/2;
	scene.add(this.floor);
  
	texture = THREE.ImageUtils.loadTexture('https://i.imgur.com/r7rjUNg.jpg');
	this.ground = new THREE.Mesh(new THREE.PlaneBufferGeometry(100,100,32), new THREE.MeshBasicMaterial({map: texture, 
                         transparent: true, 
                         side:THREE.DoubleSide}));
	this.ground.position.y -= 0.02;
	this.ground.rotation.x=-Math.PI/2;
	scene.add(this.ground);

	this.line1 = new THREE.Mesh(new THREE.PlaneBufferGeometry(16,0.125,32), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color: 0xffffff}));
	this.line1.rotation.x=-Math.PI/2;
	this.line1.position.set(0, 0.05, 4.0625);
	scene.add(this.line1);
	this.line2 = this.line1.clone();
	this.line2.position.set(0, 0.05, -4.0625);
	scene.add(this.line2);
	this.line3 = new THREE.Mesh(new THREE.PlaneBufferGeometry(8.25,0.125,32), new THREE.MeshBasicMaterial({side: THREE.DoubleSide, color: 0xffffff}));
	this.line3.rotation.x=-Math.PI/2;
	this.line3.rotation.z=-Math.PI/2;
	this.line3.position.set(-8.0625, 0.05, 0);
	scene.add(this.line3);
	this.line4 = this.line3.clone();
	this.line4.position.set(8.0625, 0.05, 0);
	scene.add(this.line4);
	
	var cylinder = new THREE.Mesh(new THREE.CylinderGeometry(0.1,0.1,2.55,32),new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color: 0xffffff}));
  	var cylinder2 = cylinder.clone();
  	cylinder.position.set(0,2.55/2,4.1);
  	cylinder2.position.set(0,2.55/2,-4.1);
  	scene.add(cylinder);
  	scene.add(cylinder2);
  
  	texture = THREE.ImageUtils.loadTexture('https://i.imgur.com/xqMo1dt.png');
  	var net = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.8,8,32),new THREE.MeshBasicMaterial({map: texture, 
                         transparent: true, 
                         opacity :0.15,
                         side:THREE.DoubleSide})); 
  	net.position.set(0,1.93,0);
  	net.rotation.z=Math.PI/2;
  	net.rotation.y=Math.PI/2;
  	scene.add(net);
    var netTop = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.08,8,32), new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color: 0xffffff}));
    netTop.position.set(0,2.37,0);
  	netTop.rotation.z=Math.PI/2;
  	netTop.rotation.y=Math.PI/2;
  	scene.add(netTop);
    var netBottom = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.08,8,32), new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color: 0xffffff}));
    netBottom.position.set(0,1.49,0);
  	netBottom.rotation.z=Math.PI/2;
  	netBottom.rotation.y=Math.PI/2;
  	scene.add(netBottom);
};

///////////////////////////////////////////////////////////////////////////
var Ball = function (scene){
  this.v = new THREE.Vector3(0, 0, 0);
  this.angle = 0;
  this.isOn = false;
  
  THREE.ImageUtils.crossOrigin = '';
  var texture =
  THREE.ImageUtils.loadTexture('https://i.imgur.com/vSpU7ik.png');
  
	this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({map: texture, 
                         transparent: true, 
                         side:THREE.DoubleSide}));
  this.mesh.position.set(0, 0.2, 0);
 	scene.add(this.mesh);
  
  this.start = function () {
    this.isOn = true;
  };
  
  this.update = function(dT) {
  	if (this.isOn === false) return;
	
  	var f = new THREE.Vector3(0, -9.8, 0);
    this.v.add ( f.clone().multiplyScalar(dT) );
  	this.mesh.position.add ( this.v.clone().multiplyScalar(dT) );
    this.mesh.rotation.z += 0.03; 
    
    this.netCollisionDetection();
    
    var n = new THREE.Vector3(0, 1, 0);
		var p0 = new THREE.Vector3(0, 0.2, 0); 
		if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    console.log(this.mesh.position.x + " " + this.mesh.position.z);
    	if(referee.whoLastHit === 1) {
      	if(this.mesh.position.x > -8 && this.mesh.position.x < 0 && this.mesh.position.z < 4 && this.mesh.position.z > -4)
        	referee.rHandUp = true;
        else
      		referee.lHandUp = true;
        referee.whoLastHit = 0;
      }
      else if(referee.whoLastHit === 2) {
      	if(this.mesh.position.x < 8 && this.mesh.position.x > 0 && this.mesh.position.z < 4 && this.mesh.position.z > -4)
        	referee.lHandUp = true;
        else 
      		referee.rHandUp = true;
        referee.whoLastHit = 0;
      }
    	//referee.playing = false; //遊戲停止
      //referee.resetPlayerPosition();
      player1.state = 7;
      player2.state = 7;
      npcPlayer1.state = 7;
      npcPlayer2.state = 7;
      var tmp = this.v.clone().dot(n);
      var v1 = n.clone().multiplyScalar(tmp);
    	var v2 = this.v.clone().sub(v1);
      v1.multiplyScalar(-0.4);
    	this.v = v1.add(v2);
      this.mesh.position.y = 0.205;
		}
    
  };
  
  this.shoot = function(v) {//傳入vector3，會從現在的ball的mesh的位置發射
		this.v = v;//初速
  };

};

Ball.prototype.collisionDetection = function(p, p0, n){
	var tmp = p.clone().sub(p0).dot(n);
  if (tmp < 0) return false;
  else return true;
}

Ball.prototype.netCollisionDetection = function(){
	var n, p0;
  if(this.mesh.position.x < 0) {
  	p0 = new THREE.Vector3(-0.2, 1.43, -4);
  	n = new THREE.Vector3(-1, 0, 0);
  }
  else {
  	p0 = new THREE.Vector3(0.2, 1.43, -4);
  	n = new THREE.Vector3(1, 0, 0);
  }
  var tmp = this.mesh.position.clone().sub(p0);
  
  if( tmp.y <= 1 && tmp.y >= 0 && tmp.z <= 8 && tmp.z >= 0 ) {
    if(!this.collisionDetection(this.mesh.position, p0, n)) {
    	tmp = this.v.clone().dot(n);
      var v1 = n.clone().multiplyScalar(tmp);
    	var v2 = this.v.clone().sub(v1);
      v1.multiplyScalar(-0.3);
    	this.v = v1.add(v2);
      if(ball.mesh.position.x < 0) this.mesh.position.x = -0.2;
      else if(ball.mesh.position.x > 0) this.mesh.position.x = 0.2;
    }
  }
}

function rotation(vector3, theta, phi) {
  var x = vector3.x * Math.cos(theta) - vector3.y * Math.sin(theta);
  var y = vector3.x * Math.sin(theta) + vector3.y * Math.cos(theta);
  vector3.x = x; 
  vector3.y = y;
  x = vector3.x * Math.cos(phi) + vector3.z * Math.sin(phi);
  var z = vector3.z * Math.cos(phi) - vector3.x * Math.sin(phi);
  vector3.x = x;
  vector3.z = z;
  return vector3;
}

///////////////////////////////////////////////////////////////////////////
var MAXSPEED = 5;
var ARRIVAL_R = 0.5;

var Agent = function (pos, vel) {
	this.pos = pos.clone();
	this.vel = vel.clone();
	this.force = new THREE.Vector3();
	this.target = new THREE.Vector3();
	this.mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.4, 0.2, 32),new THREE.MeshLambertMaterial({
		side: THREE.DoubleSide,
    transparent: true,
		opacity :0.0,
		color: 0x00ffff
	}));
};

Agent.prototype.step = function (dt) 
{
	this.accumForce();
	
	// vel += force*dt
	var tmp = this.force.clone();
	tmp.multiplyScalar (dt);
	this.vel.add (tmp);  

	// velocity modulation by arriving
	var diff = new THREE.Vector3();
	diff.subVectors (this.target, this.pos);
	var dst = diff.length();
	if (dst < ARRIVAL_R) {
		this.vel.setLength (dst);	
	}
	
	// pos += vel*dt
	tmp.copy (this.vel);
	tmp.multiplyScalar (dt*1.5);
	this.pos.add (tmp); 
};

Agent.prototype.accumForce = function ()
{
	// clear force accumulator
	this.force.set (0,0,0);
	
	var sum = new THREE.Vector3(0,0,0);
	
	// seek
	var tmp = new THREE.Vector3();
	tmp.subVectors (this.target, this.pos);
	tmp.normalize();
	tmp.multiplyScalar (MAXSPEED);
	sum.subVectors (tmp, this.vel);
	
	this.force.copy (sum);
}

///////////////////////////////////////////////////////////////////////////
var robot = function (scene, npc, num){
	
	this.hitBallMachine = new THREE.Object3D();
	THREE.ImageUtils.crossOrigin = '';
	if(npc) {
  	if(num === 1) var bodyColor = THREE.ImageUtils.loadTexture('https://i.imgur.com/pPqkHmM.png');
    else var bodyColor = THREE.ImageUtils.loadTexture('https://i.imgur.com/XdCJXRz.png');
  }
  else {
  	if(num === 1) var bodyColor = THREE.ImageUtils.loadTexture('https://i.imgur.com/oxRKc6I.png');
    else var bodyColor = THREE.ImageUtils.loadTexture('https://i.imgur.com/fDrp2FJ.png');
  }
	var geometry = new THREE.CylinderGeometry(0.24, 0.24, 1.2, 32);
	var material = new THREE.MeshLambertMaterial({map: bodyColor});
	this.body = new THREE.Object3D();
	var mesh = new THREE.Mesh(geometry, material);
	mesh.position.set(0, 0.6, 0);
	this.body.add(mesh);
	this.hitBallMachine.add(this.body);
  
	geometry = new THREE.SphereGeometry(0.25, 32, 32);
  if(npc) material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/tajmEfb.png')});
  else material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/f9dNfsj.jpg')});
	var head = new THREE.Mesh(geometry, material);
	head.position.set(0, 1.4, 0);
	this.body.add(head);
  
  material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/yNp5hMw.jpg')});
	this.hitBallMachineHandLeft = new THREE.Object3D();
	this.body.add(this.hitBallMachineHandLeft);
	this.hitBallMachineHandLeft.rotation.z = 0.25;
	this.hitBallMachineHandLeft.position.y = 1.1;
	this.hitBallMachineHandLeft.rotation.x = Math.PI/2;
	var armLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 32), material);
	armLeft.position.set(-0.33, -0.5, 0);
	this.hitBallMachineHandLeft.add(armLeft);
	
	this.hitBallMachineHandRight = new THREE.Object3D();
	this.body.add(this.hitBallMachineHandRight);
	this.hitBallMachineHandRight.rotation.z = -0.25;
	this.hitBallMachineHandRight.position.y = 1.1;
	this.hitBallMachineHandRight.rotation.x = Math.PI/2;
	var armRight = armLeft.clone();
	armRight.position.set(0.33, -0.5, 0);
	this.hitBallMachineHandRight.add(armRight);
  
	this.handLeft = new THREE.Mesh(new THREE.SphereGeometry(0.1, 32, 32), material);
	this.handLeft.position.set(-0.33, -1, 0);
	this.hitBallMachineHandLeft.add(this.handLeft);
	this.handRight = this.handLeft.clone();
	this.handRight.position.set(0.33, -1, 0);
	this.hitBallMachineHandRight.add(this.handRight);
  	
	var foot = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), material);
	this.hitBallMachine.add(foot);
  
	this.body.rotation.x = -0.2;
	this.hitBallMachineHandLeft.rotation.x = 0.9;
	this.hitBallMachine.rotation.y = Math.PI/2;
	this.hitBallMachine.position.set(0, 0.4, 0);
	scene.add(this.hitBallMachine);
 
};

///////////////////////////////////////////////////////////////////////////
var BUMP = Math.PI/3.49;
var player = function(npc, num) {
		
    this.state = 0; //0:待機  1:發球 2:standBy 3:做球 4:normal攻擊 5:殺球攻擊 //6:移動到殺球地點
    this.npc = npc; //1：電腦, 2：玩家
    this.num = num; //背號
    this.standByPosition = new THREE.Vector3(0, 0, 0);
    this.chaseTarget = new THREE.Vector3(0, 0 ,0);
    this.hitMode = 0;
    //發球用
		this.serveAngleLeft = 0;
		this.serveAngleRight = 0;
		this.startTime = 0;
		this.serveIsOn = false;
		this.serveState = 0;//0,左右手往後 1,右手往前 2,打到球後兩手收回
    this.serveTarget;
    this.isLeft = false;
    //update用
    this.updateAngleLeft = BUMP;
    this.updateAngleRight = BUMP;
    //跳越用
    this.jumpIsOn = false;
	this.jumpServeIsOn = false;
    this.jumpStartTime = 0;
	this.jumpServeState = 0//0:拋球動作，1:拋完球standBy不動，2跳起來，3手準備揮,4手揮出，球射出去了,手正在歸位,5手歸完位，身體正在歸位(著地)
  	this.jumpV = new THREE.Vector3(0, 0, 0);
    this.jumpWaitTime = 0;//等待時間，發球跟殺球共用
    this.jumpState = 0;
    
    //玩家操控的攻擊點
    this.attackTarget = new THREE.Vector3(-4, 0, 0);
    
    this.board = new Agent (new THREE.Vector3 (0, 0, 0), new THREE.Vector3(0,0,0));
    this.robot = new robot (scene, npc, this.num);
    scene.add(this.board.mesh);
    
    this.bump();
 	
  	
 		this.sprite = new SpriteText2D('seek', {
    	align: textAlign.center,
    	font: '20px Courier',
    	fillStyle: '#000000',
    	antialias: true
 	 	});
    this.sprite.scale.set(.02, .02, .02);
  	scene.add(this.sprite);
}

player.prototype.bump = function(){
    if(this.npc) {
    	this.robot.body.rotation.x = 0.2; //Math.PI/15.7
		this.robot.hitBallMachineHandLeft.rotation.x = -0.9; //-Math.PI/3.49
		this.robot.hitBallMachineHandRight.rotation.x = -0.9; //-Math.PI/3.49
        this.board.mesh.position.y = 1.1; //Math.PI/2.85
        this.board.mesh.rotation.z = -0.75; //-Math.PI/4.18; //-0.75
    }
    else {
        this.robot.body.rotation.x = -0.2;
		this.robot.hitBallMachineHandLeft.rotation.x = 0.9;
		this.robot.hitBallMachineHandRight.rotation.x = 0.9;
        this.board.mesh.position.y = 1.1;
        this.board.mesh.rotation.z = 0.75;
    } 
}

player.prototype.set = function(){
    if(this.npc) {
        this.robot.body.rotation.x = 0;
    	this.robot.hitBallMachineHandLeft.rotation.x = -2.1;
    	this.robot.hitBallMachineHandRight.rotation.x = -2.1;
    	this.board.mesh.position.y = 2.05;
    	this.board.mesh.rotation.z = -0.75;
    }
    else {
    	this.robot.body.rotation.x = 0;
    	this.robot.hitBallMachineHandLeft.rotation.x = 2.1;
    	this.robot.hitBallMachineHandRight.rotation.x = 2.1;
    	this.board.mesh.position.y = 2.05;
    	this.board.mesh.rotation.z = 0.75;
    }
}

player.prototype.startServe = function (target) {
		this.serveTarget = target;
		this.startTime = clock.getElapsedTime();
    this.serveIsOn = true;
    this.state = 1;
}

player.prototype.startJump = function(target,jumpV,waitTime){
	this.state = 1;
	this.serveTarget = target;
	this.jumpServeIsOn = true;
	this.jumpIsOn = true;
	this.jumpStartTime = clock.getElapsedTime();
	this.jumpV = jumpV;//初速
	this.jumpWaitTime = waitTime;
}
player.prototype.serve = function(dT){
	this.normalServe();
  this.jumpServe(dT);
}


player.prototype.normalServe = function(){
		if (this.serveIsOn === false) return;
    //console.log(this.state);
		var now = clock.getElapsedTime();
      //console.log(this.serveState)
    if(ball.isOn === false)//球跟著手
  		ball.mesh.position.copy(this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)));//NPC的話其實是左手
		
		if(this.serveState == 0){//如果現在不在Rest中就用BUMP狀態開始用加的
		 	this.serveAngleLeft = BUMP+ (now - this.startTime)*2 ;
		 	this.serveAngleRight = BUMP+ (now - this.startTime)*2*1.5;
		}
    else if(this.serveState == 1){//到Math.PI會迴轉所以從Math.PI開始減
    	this.serveAngleRight = Math.PI*1.3567- (now - this.startTime)*6;
    }
    else{
    	this.serveAngleLeft = Math.PI- (now - this.startTime)*6 ;
    	this.serveAngleRight = Math.PI- (now - this.startTime)*6 ;
    }
    
    
	if (this.serveState == 0 && this.serveAngleLeft > Math.PI){
		this.startTime = clock.getElapsedTime();
		this.serveState = 1;
	}
    if (this.serveState == 1 && this.serveAngleRight < Math.PI &&  ball.isOn === false){
			//ball.isOn=true;
      //ball.shoot(new THREE.Vector3(8, 9, 0));
      //console.log(ball.mesh.position);
      ball.isOn = true;
      this.passTarget(this.serveTarget);
      spikeSound.pause();
			spikeSound.currentTime = 0;
    	spikeSound.play();
      
      this.startTime = clock.getElapsedTime();
      this.serveState=2;
		}
    if(this.serveState == 2 && this.serveAngleLeft < BUMP){
    	this.serveAngleLeft = BUMP;
      this.serveAngleRight = BUMP;
      this.serveState = 0;
      this.serveIsOn = false;
      this.state = 2;///發完球變成stand by
      this.stateTarget = undefined;
    }
    if(this.isLeft === true){
      this.robot.hitBallMachineHandLeft.rotation.x = -1*this.serveAngleRight;//-1反過來，左右手也是
      this.robot.hitBallMachineHandRight.rotation.x = -1*this.serveAngleLeft; 
    } 
    else{
    	this.robot.hitBallMachineHandLeft.rotation.x = this.serveAngleRight;
      this.robot.hitBallMachineHandRight.rotation.x = this.serveAngleLeft;  
    }
}

player.prototype.jumpServe = function(dT){//dT其實是傳給jump用的，發球動作是用jumpStartTime
	if (this.jumpServeIsOn === false) return;
	var now = clock.getElapsedTime();
	//console.log(this.jumpServeState)
    if(ball.isOn === false)//球跟著手
  		ball.mesh.position.copy(this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)));//NPC的話其實是左手
	if(this.jumpServeState == 0){
		this.serveAngleLeft = BUMP+ (now - this.jumpStartTime)*2 ;
		this.serveAngleRight = BUMP+ (now - this.jumpStartTime)*2*1.5;
	}
	if(this.jumpServeState == 3){
		this.serveAngleRight = Math.PI*1.3567- (now - this.jumpStartTime)*6;
	}
  if(this.jumpServeState == 4){
    this.serveAngleLeft = Math.PI- (now - this.jumpStartTime)*6 ;
    this.serveAngleRight = Math.PI- (now - this.jumpStartTime)*6 ;
  }

	if (this.jumpServeState == 0 && this.serveAngleLeft > Math.PI){
		this.jumpStartTime = clock.getElapsedTime();
		this.jumpServeState = 1;
		ball.isOn = true;
		ball.shoot(new THREE.Vector3(0, 5.5, 0));
	}
	if(this.jumpServeState == 1 && (now - this.jumpStartTime) > this.jumpWaitTime){
		this.jumpServeState = 2;
	}
	if(this.jumpServeState >= 2){
		this.jump(dT);
	}
	if(this.jumpServeState == 2){
		var ballY =  ball.mesh.position.y;
		var handY = this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)).y;
		//console.log(Math.abs(ballY-handY));
		if(Math.abs(ballY-handY)<0.85){
		  this.jumpServeState = 3;
		  this.jumpStartTime = clock.getElapsedTime();
		
		}
	}
	if(this.jumpServeState == 3 && this.serveAngleRight < Math.PI){
		this.jumpStartTime = clock.getElapsedTime();
		this.jumpServeState = 4;
		console.log("check");
		ball.isOn = true;
    this.passTarget(this.serveTarget);
    spikeSound.pause();
		spikeSound.currentTime = 0;
    spikeSound.play();
	}
  if(this.jumpServeState == 4 && this.serveAngleLeft < BUMP){
	  this.jumpServeState = 5;
  }
  if(this.jumpServeState == 5 &&  this.jumpIsOn === false){
    this.serveAngleLeft = BUMP;
    this.serveAngleRight = BUMP;
    this.jumpServeState = 0;
    this.jumpServeIsOn = false;
    this.state = 2;///發完球變成stand by
    this.stateTarget = undefined;
  }
    if(this.isLeft === true){
      this.robot.hitBallMachineHandLeft.rotation.x = -1*this.serveAngleRight;//-1反過來，左右手也是
      this.robot.hitBallMachineHandRight.rotation.x = -1*this.serveAngleLeft; 
    } 
    else{
    	this.robot.hitBallMachineHandLeft.rotation.x = this.serveAngleRight;
      this.robot.hitBallMachineHandRight.rotation.x = this.serveAngleLeft;  
    }
}


player.prototype.jump = function(dT){
  if (this.jumpIsOn === false) return;
	//console.log(this.robot.hitBallMachine.position.y);
	/*
  if(this.jumpV.y==5)
	this.recordTime = 0;
  else
	this.recordTime+=dT;
*/
  var f = new THREE.Vector3(0, -9.8, 0);
  var robotPos = new THREE.Vector3(0, 0, 0);
  this.jumpV.add ( f.clone().multiplyScalar(dT) );
  robotPos.copy(this.robot.hitBallMachine.position);
  robotPos.add ( this.jumpV.clone().multiplyScalar(dT) );
  this.robot.hitBallMachine.position.y = robotPos.y;
  if(this.jumpV.y<0){
	  //console.log(ball.mesh.position.y);
  }
  if(this.robot.hitBallMachine.position.y <= 0.39){
    this.robot.hitBallMachine.position.y = 0.4;
  	this.jumpIsOn=false; 
  } 
}

player.prototype.predict = function(end){//傳進預測點end

	
    end.y=ball.mesh.position.y;
    /*
    var predictMesh = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({transparent: true, 
                         side:THREE.DoubleSide}));
  predictMesh.position.copy(end);
 	scene.add(predictMesh);	
    */
	var predictTargetPos = new THREE.Vector3(0, 0, 0);
    predictTargetPos.copy(end); //為不改變end值，這邊複製給另外一個
    var length = predictTargetPos.sub(ball.mesh.position).length(); //計算目前位置跟預測點的水平距離
		
    if(this.state===1 || this.state===5){
    	//console.log("check");
      var v0 = 10; //設定初速，依據不同距離給不同初速
      var temp = length*9.8/(v0*v0); //算出sin-1裡面的部分
      if(temp<1) var theta = 0.5*Math.asin(temp); //如果小於1
      else{//大於一不能放進Math.asin，重新調v0到剛好足夠的數字
        v0 = Math.sqrt(v0*v0*(temp+0.00001));
        var theta = 0.5*Math.asin(length*9.8/(v0*v0));
      }
    }
    else if(this.state===3){
    	if(length < 2.5){
        var theta = 82/180*Math.PI;
        //console.log(theta);
        var v0 = Math.sqrt(length*9.8/Math.sin(2*theta));
      }
      else{
        var theta = 75/180*Math.PI;
        //console.log(theta);
        var v0 = Math.sqrt(length*9.8/Math.sin(2*theta));
      }
      
      //console.log(length);
    }
    else{
      var theta = 50/180*Math.PI;
      //console.log(theta);
      var v0 = Math.sqrt(length*9.8/Math.sin(2*theta));
    }
    
  	//console.log(" theta:"+theta.toFixed(1)/Math.PI*180);
	predictTargetPos.copy(end);
    var ballPos = new THREE.Vector3(0, 0, 0);
    ballPos.copy(ball.mesh.position);
    var temp3 = new THREE.Vector3(1, 0, 0);
    
    if(ball.mesh.position.z<end.z)
    	var phi = -1* temp3.angleTo(predictTargetPos.sub(ballPos));
    else
    	var phi = 1* temp3.angleTo(predictTargetPos.sub(ballPos));
    //ball.isOn=true;
	//ball.shoot(rotation(new THREE.Vector3(v0, 0, 0), theta, phi ));
    
    return [v0, theta, phi];
		//ball.v = rotation(new THREE.Vector3(v0, 0, 0), theta, phi);
}

player.prototype.predictY = function(v0, theta, phi, ye){
  var ys = ball.mesh.position.y;
  var a = 4.9; // 9.8/2
  var b = -v0 * Math.sin(theta);
  var c = ye - ys;
  var t = (b*(-1) + Math.sqrt(Math.pow(b, 2) - 4*a*c)) / (2*a);
  //console.log(t);
  
  var L = v0 * Math.cos(theta) * t;
  var movement = new THREE.Vector3(L, 0, 0);
  var axis = new THREE.Vector3( 0, 1, 0 );
  movement.applyAxisAngle(axis, phi);
  var finalP = new THREE.Vector3( 0, 0, 0 );
  finalP.addVectors(ball.mesh.position.clone(), movement);
  finalP.y = ye;
  /*
	var predictMesh = new THREE.Mesh(new THREE.SphereGeometry(0.2, 32, 32), new THREE.MeshBasicMaterial({transparent: true, 
						 side:THREE.DoubleSide,color: 0x00ffff}));
	predictMesh.position.copy(finalP);
	scene.add(predictMesh);	
*/
  
  
  
  return [finalP,t];
}

  
player.prototype.update = function(dT){
	if(player1.state === 0 && player2.state === 0 && npcPlayer1.state === 0 && npcPlayer2.state === 0) {
  	if(referee.whoServe === 1) {
    	referee.whoLastHit = 2;
    	referee.whoServe = 2;
			ball.isOn = false;
  		referee.playing = true;
  		var tmp = Math.random();
      //console.log(tmp);
  		if(tmp > 0.5)
				npcPlayer1.startJump(new THREE.Vector3(4, 2.51, 0),new THREE.Vector3(0, 5, 0),0.1);  
  		else 
				npcPlayer1.startServe(new THREE.Vector3(4, 2.51, 0));
    }
  	return;
  }
	if(this.state === 1){
  	this.serve(dT);
    return;//必要，不然會被下面的調整手臂洗掉機器人的手的位置
  }

	//if(this.state === 0 || this.state === 1) return;
  
  else if(this.state === 2){ //standBy
  	this.board.target.copy(this.standByPosition);
  	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
  	this.board.mesh.position.x = this.board.pos.x;
  	this.board.mesh.position.z = this.board.pos.z;
    if(this.npc) var frontOrBack = -0.8;
    else var frontOrBack = 0.8;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
    
    if(this.hitMode === 0) {
    	if(this.board.mesh.position.y > 1.1)
      	this.board.mesh.position.y -= 0.02;
        
      if(this.updateAngleLeft>BUMP){
    		this.updateAngleLeft -= dT;
    		this.updateAngleRight -= dT;
      }
    }
  }
  
  else if(this.state === 3){ //做球
  	var n = rotation(new THREE.Vector3(0, 1, 0), this.board.mesh.rotation.z, 0); //板子(手)的法線向量
		var p0 = this.board.mesh.localToWorld(new THREE.Vector3(0, -0.1, 0)); 
    // p0為板子(手)上的一點
    var distance = ball.mesh.position.clone().sub(this.board.mesh.localToWorld(new THREE.Vector3(0, 0.3, 0))).lengthSq(); //球與板子(手)的距離
    
  	
    if(distance < 3) { //球跟板子(手)距離小於3，手就開始往上揮
    	this.board.mesh.position.add(n.clone().multiplyScalar(dT*3));
    	this.updateAngleLeft += dT*3;
    	this.updateAngleRight +=  dT*3;
    
    }
    
    if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    //球運動到跟板子(手)同平面
    	var r = ball.mesh.position.clone().sub(p0);
      var r1 = r.clone().sub(n.clone().multiplyScalar(r.clone().dot(n))).lengthSq();
      if (Math.abs(r1) <= 0.16) { //球在板子(手)的範圍內      	
      	if(this.isLeft) {
        	referee.whoLastHit = 2;
        	//this.passTarget(new THREE.Vector3(2, 0, 0));
          var tmp = this.predict(new THREE.Vector3(-2, 0, 0)); //算出到(x, 0, z)的速度與角度
          var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2]));
  				
          if(this.num === 1) {
          	if(npcPlayer2.state === 6) {
            	npcPlayer2.state = 5; //殺球
      				npcPlayer2.chaseTarget = new THREE.Vector3(-2, 3.7, 0);
	  					npcPlayer2.jumpWaitTime = jumpTarget[1];
	  					npcPlayer2.jumpV = new THREE.Vector3(0, 5, 0);
	  					npcPlayer2.jumpIsOn = true;
            }
          }
          else if(this.num === 2) {
          	if(npcPlayer1.state === 6) {
            	npcPlayer1.state = 5; //殺球
      				npcPlayer1.chaseTarget = new THREE.Vector3(-2, 3.7, 0);
	  					npcPlayer1.jumpWaitTime = jumpTarget[1];
	  					npcPlayer1.jumpV = new THREE.Vector3(0, 5, 0);
	  					npcPlayer1.jumpIsOn = true;
            }
          }
        }
        else {
        	referee.whoLastHit = 1;
        	//this.passTarget(new THREE.Vector3(-2, 0, 0));
          var tmp = this.predict(new THREE.Vector3(2, 0, 0)); //算出到(x, 0, z)的速度與角度
          var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2]));
  				
          if(this.num === 1) {
          	if(player2.state === 6) {
            	player2.state = 5; //殺球
      				player2.chaseTarget = new THREE.Vector3(2, 3.7, 0);
	  					player2.jumpWaitTime = jumpTarget[1];
	  					player2.jumpV = new THREE.Vector3(0, 5, 0);
	  					player2.jumpIsOn = true;
            }
          }
          else if(this.num === 2) {
          	if(player1.state === 6) {
            	player1.state = 5; //殺球
      				player1.chaseTarget = new THREE.Vector3(2, 3.7, 0);
	  					player1.jumpWaitTime = jumpTarget[1];
	  					player1.jumpV = new THREE.Vector3(0, 5, 0);
	  					player1.jumpIsOn = true;
            }
          }
        }
    		slapSound.pause();
				slapSound.currentTime = 0;
    		slapSound.play();
      }
      this.state = 2;
    }
    
  	//追落點
  	this.board.target.copy(this.chaseTarget);
  	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
  	this.board.mesh.position.x = this.board.pos.x;
  	this.board.mesh.position.z = this.board.pos.z;
    if(this.npc) var frontOrBack = -0.8;
    else var frontOrBack = 0.8;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
  }
  
  else if(this.state === 4){ //normal attack
  	var n = rotation(new THREE.Vector3(0, 1, 0), this.board.mesh.rotation.z, 0); //板子(手)的法線向量
		var p0 = this.board.mesh.localToWorld(new THREE.Vector3(0, -0.1, 0)); 
    // p0為板子(手)上的一點
    var distance = ball.mesh.position.clone().sub(this.board.mesh.localToWorld(new THREE.Vector3(0, 0.3, 0))).lengthSq(); //球與板子(手)的距離
    
    if(distance < 3) { //球跟板子(手)距離小於3，手就開始往上揮
    	this.board.mesh.position.add(n.clone().multiplyScalar(dT*3));
    	this.updateAngleLeft += dT*3;
    	this.updateAngleRight +=  dT*3;
    
    }
    if (!ball.collisionDetection(ball.mesh.position, p0, n)){	
    //球運動到跟板子(手)同平面
    	var r = ball.mesh.position.clone().sub(p0);
      var r1 = r.clone().sub(n.clone().multiplyScalar(r.clone().dot(n))).lengthSq();
      if (Math.abs(r1) <= 0.16) { //球在板子(手)的範圍內      	
      	var x = Math.random() * 3.5 + 3;
        //var x = 6;
        var z = Math.random() * 7 - 3.5;
        //var z = 1;
        if(this.isLeft) {
        	referee.whoLastHit = 2;
        	this.passTarget(new THREE.Vector3(x, 0, z));
        }
        else {
        	referee.whoLastHit = 1;
        	this.passTarget(this.attackTarget);
        }
        this.state = 2;
        
        slapSound.pause();
				slapSound.currentTime = 0;
    		slapSound.play();
      }
      if(!this.isLeft){
      	if(playerCoach.isOne) this.state = 2;
      }
      else if(this.isLeft){
      	if(npcCoach.isOne) this.state = 2;
      }
    }
    
    //追落點
	this.board.target.copy(this.chaseTarget);
	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
	this.board.mesh.position.x = this.board.pos.x;
	this.board.mesh.position.z = this.board.pos.z;
	if(this.npc) var frontOrBack = -0.8;
	else var frontOrBack = 0.8;	this.robot.hitBallMachine.position.set(this.board.mesh.position.x+frontOrBack, 0.4, this.board.mesh.position.z);
  }
  
  else if(this.state === 5){ //殺球
	
	
	this.jumpWaitTime -=dT;
	
	if(this.updateAngleRight <= Math.PI && this.jumpState === 0){
    	this.updateAngleLeft += dT*5;
    	this.updateAngleRight +=  dT*5;	
	}
	//if(this.jumpWaitTime<0.1 && this.jumpWaitTime>-0.1 )
		//console.log(this.robot.handRight.localToWorld(new THREE.Vector3(0,0,0)));
		
	
	if(this.jumpWaitTime<0 && this.jumpState === 0){
		//console.log(ball.mesh.position.y);
		  if(this.isLeft) {
      	referee.whoLastHit = 2;
      	var x = Math.random() * 1.5;
       	var z = Math.random() * 2 - 1;
      }
      else {
      	referee.whoLastHit = 1;
      	if(attackPosRange === 0) var z = 2;
  			else if(attackPosRange === 1) var z = 0;
  			else if(attackPosRange ===2) var z = -2;
        z += Math.random() - 0.5;
  			var x = Math.random() * (-1) - 1;   
      }
      this.passTarget(new THREE.Vector3(x, 0, z));
			this.jumpState = 1;
      spikeSound.pause();
			spikeSound.currentTime = 0;
    	spikeSound.play();
	}
	
	if(this.jumpIsOn == false){
		this.state = 2;
		this.jumpState = 0;
	}
	
	if(this.jumpWaitTime<0.7){
		this.jump(dT);
		
    	this.updateAngleLeft -= dT*3;
    	this.updateAngleRight -=  dT*3;	
	}
	else
		console.log("check wait");
	
	//追落點
	this.board.target.copy(this.chaseTarget);
	this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
	this.board.mesh.position.x = this.board.pos.x;
	this.board.mesh.position.z = this.board.pos.z;
	if(this.npc) var frontOrBack = -0.8;
	else var frontOrBack = 0.8;	
	
	//this.robot.hitBallMachine.position.x = this.board.mesh.position.x;
	this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;

  }
  else if(this.state === 6){ //移動到殺球位置
  	//追落點
		this.board.target.copy(this.chaseTarget);
		this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
		this.board.mesh.position.x = this.board.pos.x;
		this.board.mesh.position.z = this.board.pos.z;
		if(this.npc) var frontOrBack = -0.8;
		else var frontOrBack = 0.8;	
	
		this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;
  }
  
  else if(this.state === 7){ //回到起始位置
  	//追落點
    if(referee.whoServe === 1) {
    	if(this.isLeft) {
    		if(this.num === 1) this.chaseTarget = new THREE.Vector3(-9, 1.1, 0);
      	else this.chaseTarget = new THREE.Vector3(-4, 1.1, 2);
    	}
    	else {
    		if(this.num === 1) this.chaseTarget = new THREE.Vector3(4, 1.1, -2);
      	else this.chaseTarget = new THREE.Vector3(4, 1.1, 2);
    	}
    }
    else {
    	if(this.isLeft) {
    		if(this.num === 1) this.chaseTarget = new THREE.Vector3(-4, 1.1, -2);
      	else this.chaseTarget = new THREE.Vector3(-4, 1.1, 2);
    	}
    	else {
    		if(this.num === 1) this.chaseTarget = new THREE.Vector3(9, 1.1, 0);
      	else this.chaseTarget = new THREE.Vector3(4, 1.1, 2);
    	}
    }
		this.board.target.copy(this.chaseTarget);
		this.board.pos.copy(this.board.mesh.position);
		this.board.step(dT);
		this.board.mesh.position.x = this.board.pos.x;
		this.board.mesh.position.z = this.board.pos.z;
		if(this.npc) var frontOrBack = -0.8;
		else var frontOrBack = 0.8;	
	
		this.robot.hitBallMachine.position.x = this.board.mesh.position.x+frontOrBack;
	this.robot.hitBallMachine.position.z = this.board.mesh.position.z;
  
  	//回到待機狀態
  	if(this.board.mesh.position.clone().sub(this.chaseTarget).length() < 1) {
    	this.board.vel = new THREE.Vector3(0, 0, 0);
    	this.state = 0;
    }
  }
  
  //實際改robot的數值
  
  if(this.isLeft === true){
    this.robot.hitBallMachineHandLeft.rotation.x = -1*this.updateAngleRight;//-1反過來，左右手也是
    this.robot.hitBallMachineHandRight.rotation.x = -1*this.updateAngleLeft; 
    
  } 
  else{
    this.robot.hitBallMachineHandLeft.rotation.x = this.updateAngleRight;
    this.robot.hitBallMachineHandRight.rotation.x = this.updateAngleLeft;  
  }
  
}


player.prototype.passTarget = function(end){
  var tmp = this.predict(end); //算出到(x, 0, z)的速度與角度
  ball.shoot(rotation(new THREE.Vector3(tmp[0], 0, 0), tmp[1], tmp[2])); //將球射出去
  var bumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 1.1); //算出球運動到y=1.1時的位置
  var jumpTarget = this.predictY(tmp[0], tmp[1], tmp[2], 3.7);
  var groundTarget = this.predictY(tmp[0], tmp[1], tmp[2], 0.2);
  //將y=1.1時的位置傳給對場的coach
  if(this.isLeft) {
  	playerCoach.isOn = true;
    playerCoach.groundTarget = groundTarget[0];
  	playerCoach.bumpTarget = bumpTarget[0];
		playerCoach.jumpTarget = jumpTarget[0];
		playerCoach.jumpTime = jumpTarget[1];
	
  }
  else {
   	npcCoach.isOn = true;
    npcCoach.groundTarget = groundTarget[0];
  	npcCoach.bumpTarget = bumpTarget[0];
  	npcCoach.jumpTarget = jumpTarget[0];
		npcCoach.jumpTime = jumpTarget[1];
  }
}

///////////////////////////////////////////////////////////////////////////
var referee = function() {
	//若接發球方贏得一球，除了得一分之外，並取得發球權。而只要發球權交換，獲得發球權球隊球員也必須輪替。
  this.playing = false;
  this.whoServe; //1:player 2:npc
  this.whoLastHit;
  this.lHandUp = false;
  this.rHandUp = false;
  
  this.hitBallMachine = new THREE.Object3D();
  THREE.ImageUtils.crossOrigin = '';
	var geometry = new THREE.CylinderGeometry(0.24, 0.24, 1.2, 32);
	var material = new THREE.MeshLambertMaterial({color: 0x00ff00});
	this.body = new THREE.Object3D();
	var mesh = new THREE.Mesh(geometry, material);
	mesh.position.set(0, 0.6, 0);
	this.body.add(mesh);
	this.hitBallMachine.add(this.body);
  
	geometry = new THREE.SphereGeometry(0.25, 32, 32);
  material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/f9dNfsj.jpg')});
	var head = new THREE.Mesh(geometry, material);
	head.position.set(0, 1.4, 0);
	this.body.add(head);
  
  material = new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('https://i.imgur.com/yNp5hMw.jpg')});
	this.hitBallMachineHandLeft = new THREE.Object3D();
	this.body.add(this.hitBallMachineHandLeft);
	this.hitBallMachineHandLeft.rotation.z = 2.7;
  this.hitBallMachineHandLeft.position.x = -0.3;
	this.hitBallMachineHandLeft.position.y = 1.1;
	var armLeft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1, 32), material);
	armLeft.position.set(0, 0.5, 0);
	this.hitBallMachineHandLeft.add(armLeft);
  var cylinder = new THREE.Mesh( new THREE.CylinderGeometry( 0.04, 0.04, 1.2, 32 ), new THREE.MeshBasicMaterial( {color: 0x804000}) );
  cylinder.rotation.z = 1.7;
  cylinder.position.set(0.4, 1.1, 0);
	this.hitBallMachineHandLeft.add( cylinder );

	var plane = new THREE.Mesh( new THREE.PlaneGeometry( 0.4, 0.7, 32 ), new THREE.MeshBasicMaterial( {color: 0xff0000, side: 	THREE.DoubleSide} ) );
	plane.rotation.z = 1.7 + Math.PI/2;
  plane.position.set(0.75, 1.5, 0);
	this.hitBallMachineHandLeft.add( plane );
	
	this.hitBallMachineHandRight = new THREE.Object3D();
	this.body.add(this.hitBallMachineHandRight);
  this.hitBallMachineHandRight.rotation.z = Math.PI - 2.7;
  this.hitBallMachineHandRight.position.x = 0.3;
	this.hitBallMachineHandRight.position.y = 1.1;
	var armRight = armLeft.clone();
	armRight.position.set(0, -0.5, 0);
	this.hitBallMachineHandRight.add(armRight);
  var cylinder2 = new THREE.Mesh( new THREE.CylinderGeometry( 0.04, 0.04, 1.2, 32 ), new THREE.MeshBasicMaterial( {color: 0x804000}) );
  cylinder2.rotation.z = 1.5;
  cylinder2.position.set(0.4, -1.1, 0);
	this.hitBallMachineHandRight.add( cylinder2 );

	var plane2 = new THREE.Mesh( new THREE.PlaneGeometry( 0.4, 0.7, 32 ), new THREE.MeshBasicMaterial( {color: 0xff0000, side: 	THREE.DoubleSide} ) );
	plane2.rotation.z = 1.5 + Math.PI/2;
  plane2.position.set(0.75, -1.5, 0);
	this.hitBallMachineHandRight.add( plane2 );
  
	var handLeft = new THREE.Mesh(new THREE.SphereGeometry(0.1, 32, 32), material);
	handLeft.position.set(0, 1, 0);
	this.hitBallMachineHandLeft.add(handLeft);
	handRight = handLeft.clone();
	handRight.position.set(0, -1, 0);
	this.hitBallMachineHandRight.add(handRight);
  	
	var foot = new THREE.Mesh(new THREE.SphereGeometry(0.4, 32, 32), material);
	this.hitBallMachine.add(foot);
  
	this.hitBallMachine.rotation.y = -0.6;
	this.hitBallMachine.position.set(0, 0.4, 5.5);
	scene.add(this.hitBallMachine);
}

referee.prototype.update = function() {
	if(!this.playing) { //遊戲停止，所有player待機
  	npcPlayer1.state = 0;
    npcPlayer2.state = 0;
    player1.state = 0;
    player2.state = 0;
  }
  this.leftHandUp();
	this.rightHandUp();
  this.leftHandDown();
  this.rightHandDown();

}

referee.prototype.resetPlayerPosition = function() {
	npcPlayer1.board.mesh.position.set(-9, 1.1, 0);
 npcPlayer1.robot.hitBallMachine.position.set(npcPlayer1.board.mesh.position.x-0.8, 0.4, npcPlayer1.board.mesh.position.z);
 	npcPlayer1.bump();
  npcPlayer2.board.mesh.position.set(-4, 1.1, 2);
 npcPlayer2.robot.hitBallMachine.position.set(npcPlayer2.board.mesh.position.x-0.8, 0.4, npcPlayer2.board.mesh.position.z);
 	npcPlayer2.bump();
  player1.board.mesh.position.set(9, 1.1, 0);
 player1.robot.hitBallMachine.position.set(player1.board.mesh.position.x+0.8, 0.4, player1.board.mesh.position.z);
 	player1.bump();
 	player2.board.mesh.position.set(4, 1.1, 2);
 player2.robot.hitBallMachine.position.set(player2.board.mesh.position.x+0.8, 0.4, player2.board.mesh.position.z);
 	player2.bump();
}

referee.prototype.leftHandUp = function() {
	if(this.lHandUp) {
  	if(this.hitBallMachineHandLeft.rotation.z > 1.4)
    	this.hitBallMachineHandLeft.rotation.z -= 0.03;
		else this.lHandUp = false;
  }
}
referee.prototype.leftHandDown = function() {
	if(!this.lHandUp) {
		if(this.hitBallMachineHandLeft.rotation.z < 2.7)
    	this.hitBallMachineHandLeft.rotation.z += 0.03;
  }
}
referee.prototype.rightHandUp = function() {
	if(this.rHandUp) {
  	if(this.hitBallMachineHandRight.rotation.z < Math.PI - 1.4)
    	this.hitBallMachineHandRight.rotation.z += 0.03;
    else this.rHandUp = false;
  }
}
referee.prototype.rightHandDown = function() {
	if(!this.rHandUp) {
		if(this.hitBallMachineHandRight.rotation.z > Math.PI - 2.7)
  		this.hitBallMachineHandRight.rotation.z -= 0.03;
  }
}
///////////////////////////////////////////////////////////////////////////
var coach = function(npc) {
  this.isOn = false;
  this.npc = npc;
  this.bumpTarget = new THREE.Vector3(0, 0, 0);
  this.jumpTarget = new THREE.Vector3(0, 0, 0);
  this.groundTarget = new THREE.Vector3(0, 0, 0);
  this.jumpTime = 0;
  this.isOne;
}

coach.prototype.update = function() {
	if (this.isOn === false) return;
  this.isOn = false;
  
  if(this.npc) {
  	npcPlayer1.board.vel = new THREE.Vector3(0, 0, 0);
    npcPlayer2.board.vel = new THREE.Vector3(0, 0, 0);
    
  	if(this.groundTarget.x < -8 || this.groundTarget.z < -4 || this.groundTarget.z > 4) {
    	npcPlayer1.state = 2;
    	npcPlayer2.state = 2;
      return;
    }
    
  	var dis1 = this.bumpTarget.clone().sub(npcPlayer1.board.mesh.position.clone()).lengthSq();
    var dis2 = this.bumpTarget.clone().sub(npcPlayer2.board.mesh.position.clone()).lengthSq();
    
	  //這邊要一個if來判斷攻擊方式?
///////////////////////////////////////////////////////////// 
		if(dis1 >= dis2) {
    	var tmp = Math.random() - 0.5;
      if(tmp > 0) {
      	this.isOne = false;
    		npcPlayer2.state = 3; //做球
      	npcPlayer2.chaseTarget = this.bumpTarget;
      }
      else {
      	this.isOne = true;
      	npcPlayer2.state = 4; //攻擊
      	npcPlayer2.chaseTarget = this.bumpTarget;
      }
      
			tmp = Math.random() - 0.5;
      if(npcPlayer2.state === 4) {
      	npcPlayer1.state = 2;
      }
      else if(tmp > 0 && npcPlayer2.state != 4) {
      	npcPlayer1.state = 6; //殺球
        npcPlayer1.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
      }
      else if(tmp < 0 && npcPlayer2.state != 4){
      	npcPlayer1.state = 4; //攻擊
      	npcPlayer1.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
      }
    }
    else {
    	var tmp = Math.random() - 0.5;
      if(tmp > 0) {
      	this.isOne = false;
    		npcPlayer1.state = 3; //做球
      	npcPlayer1.chaseTarget = this.bumpTarget;
      }
      else {
      	this.isOne = true;
      	npcPlayer1.state = 4; //攻擊
      	npcPlayer1.chaseTarget = this.bumpTarget;
      }

      tmp = Math.random() - 0.5;
      if(npcPlayer1.state === 4) {
      	npcPlayer2.state = 2;
      }
      else if(tmp > 0 && npcPlayer1.state != 4) {
      	npcPlayer2.state = 6; //殺球
        npcPlayer2.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
      }
      else if (tmp < 0 && npcPlayer1.state != 4){
      	npcPlayer2.state = 4; //攻擊
      	npcPlayer2.chaseTarget = new THREE.Vector3(-2, 1.1, 0);
      }
    }
    
/////////////////////////////////////////////////////////////

  }
  else {
  	player1.board.vel = new THREE.Vector3(0, 0, 0);
    player2.board.vel = new THREE.Vector3(0, 0, 0);
    
  	if(this.groundTarget.x > 8 || this.groundTarget.z < -4 || this.groundTarget.z > 4) {
    	player1.state = 2;
    	player2.state = 2;
      return;
    }
    
  	var dis1 = this.bumpTarget.clone().sub(player1.board.mesh.position.clone()).lengthSq();
    var dis2 = this.bumpTarget.clone().sub(player2.board.mesh.position.clone()).lengthSq();
    
    if(dis1 >= dis2) {
    	if(pass) {
      	this.isOne = false;
    		player2.state = 3; //做球
      	player2.chaseTarget = this.bumpTarget;
        if(spike) {
        	player1.state = 6; //殺球
        }
        else player1.state = 4; //攻擊
      	player1.chaseTarget = new THREE.Vector3(2, 1.1, 0);
      }
      else {
      	this.isOne = true;
      	if(spike) {
        	player2.state = 5; //殺球
      		player2.chaseTarget = this.jumpTarget;
	  			player2.jumpWaitTime = this.jumpTime;
	  			player2.jumpV = new THREE.Vector3(0, 5, 0);
	  			player2.jumpIsOn = true;
        }
        else {
        	player2.state = 4; //攻擊
      		player2.chaseTarget = this.bumpTarget;
        }
        player1.state = 2; //stand by
      }
    }
    else {
    	if(pass) {
      	this.isOne = false;
    		player1.state = 3; //做球
      	player1.chaseTarget = this.bumpTarget;
        if(spike) {
        	player2.state = 6; //殺球
        }
        else player2.state = 4; //攻擊
        player2.chaseTarget = new THREE.Vector3(2, 1.1, 0);
      }
      else {
      	this.isOne = true;
      	if(spike) {
        	player1.state = 5; //殺球
      		player1.chaseTarget = this.jumpTarget;
	  			player1.jumpWaitTime = this.jumpTime;
	  			player1.jumpV = new THREE.Vector3(0, 5, 0);
	  			player1.jumpIsOn = true;
        }
        else {
        	player1.state = 4; //攻擊
      		player1.chaseTarget = this.bumpTarget;
        }
        player2.state = 2; //stand by
      }
    }
  }
}


var scene = new THREE.Scene();
var renderer, camera, controls;
var basicScene = new BasicScene (scene);
var ball = new Ball (scene);
var clock = new THREE.Clock();
var referee = new referee();
var keyboard = new KeyboardState();
var attackPosRange = 1; //0:left 1:mid 2:right
var attackRangeLine, pass = true, spike = false;
var SpriteText2D = THREE_Text.SpriteText2D;
var textAlign = THREE_Text.textAlign;
var soundTrack, slapSound, spikeSound;

/*
$('#serve').click(function() {
	ball.isOn = false;
  referee.playing = true;
	npcPlayer1.startServe(new THREE.Vector3(4, 2.51, 0));
  
  npcPlayer2.state = 2;
	//player1.startServe();
  player1.state = 2;
  player2.state = 2;
  //npcPlayer1.state = 2;
});
*/
$("#left").click(function() {
	if(attackPosRange != 0) attackPosRange--;
  
  if(attackPosRange === 0) {
  	var lineZLeft = 0;
    var lineZRight = 4;
  }
  else if(attackPosRange === 1) {
  	var lineZLeft = -2;
    var lineZRight = 2;
  }
  else if(attackPosRange ===2) {
  	var lineZLeft = -4;
    var lineZRight = 0;
  }
	
  scene.remove(attackRangeLine);
  var attackRangeGeometry = new THREE.Geometry();  
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, lineZLeft));
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, lineZRight));
  attackRangeGeometry.vertices.push(new THREE.Vector3(0, 0.1, lineZRight));
  attackRangeGeometry.vertices.push(new THREE.Vector3(0, 0.1, lineZLeft));
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, lineZLeft));
  attackRangeLine = new THREE.Line(
    attackRangeGeometry,
    new THREE.LineBasicMaterial({ color: 0xff0000 })
   );
  scene.add(attackRangeLine);
});

$("#right").click(function() {
	if(attackPosRange != 2) attackPosRange++;
  
  if(attackPosRange === 0) {
  	var lineZLeft = 0;
    var lineZRight = 4;
  }
  else if(attackPosRange === 1) {
  	var lineZLeft = -2;
    var lineZRight = 2;
  }
  else if(attackPosRange ===2) {
  	var lineZLeft = -4;
    var lineZRight = 0;
  }
  
  scene.remove(attackRangeLine);
  var attackRangeGeometry = new THREE.Geometry();  
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, lineZLeft));
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, lineZRight));
  attackRangeGeometry.vertices.push(new THREE.Vector3(0, 0.1, lineZRight));
  attackRangeGeometry.vertices.push(new THREE.Vector3(0, 0.1, lineZLeft));
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, lineZLeft));
  attackRangeLine = new THREE.Line(
    attackRangeGeometry,
    new THREE.LineBasicMaterial({ color: 0xff0000 })
   );
  scene.add(attackRangeLine);
});

$("#pass").click(function() {
	pass = !pass;
  if(pass) this.style.backgroundColor='#999999';
  else this.style.backgroundColor='#dddddd';
});
$("#spike").click(function() {
	spike = !spike;
  if(spike) this.style.backgroundColor='#999999';
  else this.style.backgroundColor='#dddddd';
});
$('#start').click(function() {
	referee.whoLastHit = 1;
	if(player1.state === 0) {
		referee.whoServe = 1;
		ball.isOn = false;
  	referee.playing = true;
  
  	if(spike)
			player1.startJump(new THREE.Vector3(-4, 2.51, 0),new THREE.Vector3(0, 5, 0),0.1);  
  	else 
			player1.startServe(new THREE.Vector3(-4, 2.51, 0));
  }
});

init();
animate();

function init() {
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x888888);
  document.body.appendChild(renderer.domElement);

  camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.set(16.5, 7, 0);
  //camera.position.set(0, 6, 15);
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  
  //攻擊範圍
  var attackRangeGeometry = new THREE.Geometry();  
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, -2));
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, 2));
  attackRangeGeometry.vertices.push(new THREE.Vector3(0, 0.1, 2));
  attackRangeGeometry.vertices.push(new THREE.Vector3(0, 0.1, -2));
  attackRangeGeometry.vertices.push(new THREE.Vector3(-8, 0.1, -2));
  attackRangeLine = new THREE.Line(
    attackRangeGeometry,
    new THREE.LineBasicMaterial({ color: 0xff0000 })
   );
   scene.add(attackRangeLine);
  
  npcCoach = new coach(1);
  playerCoach = new coach(0);
  
  npcPlayer1 = new player(1, 1);  
  npcPlayer1.board.mesh.position.set(-4, 1.1, -2);
 npcPlayer1.robot.hitBallMachine.position.set(npcPlayer1.board.mesh.position.x-0.8, 0.4, npcPlayer1.board.mesh.position.z);
  npcPlayer1.standByPosition = new THREE.Vector3(-4, 1.1, -2);
  npcPlayer1.isLeft = true;
  
  npcPlayer2 = new player(1, 2);  
  npcPlayer2.board.mesh.position.set(-4, 1.1, 2);
 npcPlayer2.robot.hitBallMachine.position.set(npcPlayer2.board.mesh.position.x-0.8, 0.4, npcPlayer2.board.mesh.position.z);
  npcPlayer2.standByPosition = new THREE.Vector3(-4, 1.1, 2);
  npcPlayer2.isLeft = true;
  
  player1 = new player(0, 1);  
  player1.board.mesh.position.set(9, 1.1, 0);
 player1.robot.hitBallMachine.position.set(player1.board.mesh.position.x+0.8, 0.4, player1.board.mesh.position.z);
 player1.standByPosition = new THREE.Vector3(4, 1.1, -2);
 
 	player2 = new player(0, 2);  
  player2.board.mesh.position.set(4, 1.1, 2);
 player2.robot.hitBallMachine.position.set(player2.board.mesh.position.x+0.8, 0.4, player2.board.mesh.position.z);
 	player2.standByPosition = new THREE.Vector3(4, 1.1, 2);
  
  soundTrack = document.getElementById ('soundtrack');
  soundtrack.volume = 0.4;
  slapSound = document.getElementById ('slapSound');
  slapSound.volume = 1.0;
  spikeSound = document.getElementById ('spikeSound');
  spikeSound.volume = 0.5;
  
  window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {

//npcPlayer1.robot.hitBallMachineHandLeft.rotation.x = -Math.PI*1.07
  controls.update();
  keyboard.update();
  
  var dT = clock.getDelta();
  referee.update();
  ball.update(dT);
  npcCoach.update();
  playerCoach.update();
  npcPlayer1.update(dT);
  npcPlayer2.update(dT);
  player1.update(dT);
  player2.update(dT);
  
  //test jump用，之後放進去update?
  npcPlayer1.jumpServe(dT);

	//隨機攻擊點
  if(attackPosRange === 0) var z = 2;
  else if(attackPosRange === 1) var z = 0;
  else if(attackPosRange ===2) var z = -2;
  z += Math.random() * 4 - 2; 
  //var x = -4.5 + (Math.random()*7 - 3.5);
  var x = Math.random() * (-3.5) - 4;   
  player1.attackTarget = new THREE.Vector3(x, 0, z);
  player2.attackTarget = new THREE.Vector3(x, 0, z);
  
  //狀態顯示
  if(npcPlayer1.state === 0) npcPlayer1.sprite.text = "ready";
  else if(npcPlayer1.state === 1) npcPlayer1.sprite.text = "serve";
  else if(npcPlayer1.state === 2) npcPlayer1.sprite.text = "stand by";
  else if(npcPlayer1.state === 3) npcPlayer1.sprite.text = "set";
  else if(npcPlayer1.state === 4) npcPlayer1.sprite.text = "bump";
  else if(npcPlayer1.state === 5) npcPlayer1.sprite.text = "spike";
  else if(npcPlayer1.state === 6) npcPlayer1.sprite.text = "spike";
  
  if(npcPlayer2.state === 0) npcPlayer2.sprite.text = "ready";
  else if(npcPlayer2.state === 1) npcPlayer2.sprite.text = "serve";
  else if(npcPlayer2.state === 2) npcPlayer2.sprite.text = "stand by";
  else if(npcPlayer2.state === 3) npcPlayer2.sprite.text = "set";
  else if(npcPlayer2.state === 4) npcPlayer2.sprite.text = "bump";
  else if(npcPlayer2.state === 5) npcPlayer2.sprite.text = "spike";
  else if(npcPlayer2.state === 6) npcPlayer2.sprite.text = "spike";
  
  if(player1.state === 0) player1.sprite.text = "ready";
  else if(player1.state === 1) player1.sprite.text = "serve";
  else if(player1.state === 2) player1.sprite.text = "stand by";
  else if(player1.state === 3) player1.sprite.text = "set";
  else if(player1.state === 4) player1.sprite.text = "bump";
  else if(player1.state === 5) player1.sprite.text = "spike";
  else if(player1.state === 6) player1.sprite.text = "spike";
  
  if(player2.state === 0) player2.sprite.text = "ready";
  else if(player2.state === 1) player2.sprite.text = "serve";
  else if(player2.state === 2) player2.sprite.text = "stand by";
  else if(player2.state === 3) player2.sprite.text = "set";
  else if(player2.state === 4) player2.sprite.text = "bump";
  else if(player2.state === 5) player2.sprite.text = "spike";
  else if(player2.state === 6) player2.sprite.text = "spike";
  
  player1.sprite.position.copy(player1.robot.hitBallMachine.position);
  player1.sprite.position.x -= 0.5;
  player1.sprite.position.y += 2;
  player2.sprite.position.copy(player2.robot.hitBallMachine.position);
  player2.sprite.position.x -= 0.5;
  player2.sprite.position.y += 2;
  npcPlayer1.sprite.position.copy(npcPlayer1.robot.hitBallMachine.position);
  npcPlayer1.sprite.position.x += 0.5;
  npcPlayer1.sprite.position.y += 2;
  npcPlayer2.sprite.position.copy(npcPlayer2.robot.hitBallMachine.position);
  npcPlayer2.sprite.position.x += 0.5;
  npcPlayer2.sprite.position.y += 2;

  //player1.serve();
  //npcPlayer1.serve();
  //console.log(npcPlayer1.state);
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

</script>
</body>

</html>